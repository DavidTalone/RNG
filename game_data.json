{"name": "Real number game", "version": "0.1.0", "languages": ["en"], "translated_name": "0", "devmode": false, "library_zip_fn": "Real number game-0.1.0-library.zip", "introData": {"name": "", "problemIndex": -1, "objects": [{"type": "text", "content": "1"}]}, "worlds": [{"name": "2", "levels": [{"name": "", "problemIndex": 10, "objects": [{"type": "lean", "content": "3", "hidden": true}, {"type": "lean", "content": "4", "hidden": true}, {"type": "lean", "content": "5", "hidden": true}, {"type": "lean", "content": "6", "hidden": true}, {"type": "lean", "content": "7", "hidden": false}, {"type": "text", "content": "8"}, {"type": "axiom", "content": "9", "name": "subset_iff :", "sideBar": true}, {"type": "hint", "content": "10", "title": "11"}, {"type": "hint", "content": "12", "title": "13"}, {"type": "text", "content": "14"}, {"type": "lemma", "text": "15", "lean": "lemma subset.refl (A : set X) : A \u2286 A :=\n", "sideBar": true, "firstProofLineNumber": 77, "lastProofLineNumber": 79, "textBefore": "import data.set.basic -- hide\n\nimport kb_defs -- hide\n\nnamespace xena -- hide\n\nopen_locale classical -- hide\n\nvariable X : Type -- we will think of X as a set here\n\n/-\n# Chapter 1 : Sets\n\n## Level 1 : Introduction to sets.\n\nThis chapter assumes you are familiar with the following tactics:\n`rw`, `intro`, `apply`, `exact`, `cases`, `split`, `use`, `left`, `right` and `exfalso`.\n\n(TODO (kmb) : check this list is exhaustive)\n(We might need to add `ring`)\n\nIf you are not, try playing Function World and Proposition World of the Natural Number Game.\n\n## Sets in Lean\n\nIn this world, there will be an ambient \"big\" set `X` (actually `X` will be a type),\nand we will consider subsets of `X`. The type of subsets of `X` is called `set X`.\nSo if you see `A : set X` it means that `A` is a subset of `X`.\n\n## subsets (\u2286) and `subset_iff`\n\nIf `A B : set X` (i.e. `A` and `B` are subsets of `X`), then `A \u2286 B` is a\nProposition, i.e. a true/false statement. Lean knows the following fact:\n\n```\nsubset_iff : A \u2286 B \u2194 \u2200 x : X, x \u2208 A \u2192 x \u2208 B\n```\n\nLet's see if you can prove `A \u2286 A` by rewriting `subset_iff`.\n-/\n\n/- Axiom : subset_iff :\nA \u2286 B \u2194 \u2200 x : X, x \u2208 A \u2192 x \u2208 B\n-/\n\n/- Hint : Tactic tip\nThe `assumption` tactic will close a goal if it is equal to one of your\nhypotheses. It's actually longer to type than `exact hx`, but it's easier to\nuse because you don't have to bother remembering what you called `hx`.\n\n-/\n/- Hint : Stuck? Here's a hint.\nTo make progress with a goal of form `\u2200 a : X, ...`, introduce a term of type `X` by using a familiar tactic. \n\nIn this example, using\n\n`intro a,`\n\nwill introduce an arbitrary term of type `X`.\n\nNote that this is the tactic we use to assume a hypothesis (when proving an implication), or to choose an arbitrary element of some domain (when defining a function).\n\nUse the same tactic to introduce an appropriately named hypothesis for an implication, and close the goal with the `exact` tactic.\n-/\n\n/-\nIf you get stuck, you can click on the hints for more details!\n-/\n\n\n\n/- Lemma\nIf $A$ is a set of elements of type X, then $A \\subseteq A$. \n-/\nlemma subset.refl (A : set X) : A \u2286 A :=\nbegin\n", "proof": "  rw subset_iff,\n  intros x h,\n  exact h,", "proof_hint": "sorry", "textAfter": "\nend\n\n\nend xena --hide\n", "height": 3, "editorText": "sorry", "lineOffset": 76, "name": "subset.refl", "statement": "(A : set X) : A \u2286 A"}, {"type": "lean", "content": "16", "hidden": true}]}, {"name": "", "problemIndex": 9, "objects": [{"type": "lean", "content": "17", "hidden": true}, {"type": "lean", "content": "18", "hidden": true}, {"type": "lean", "content": "19", "hidden": true}, {"type": "lean", "content": "20", "hidden": true}, {"type": "text", "content": "21"}, {"type": "text", "content": "22"}, {"type": "axiom", "content": "23", "name": "mem_union_iff :", "sideBar": true}, {"type": "hint", "content": "24", "title": "25"}, {"type": "hint", "content": "26", "title": "27"}, {"type": "lemma", "text": "28", "lean": "theorem subset_union_left (A B : set X) : A \u2286 A \u222a B :=\n", "sideBar": true, "firstProofLineNumber": 54, "lastProofLineNumber": 59, "textBefore": "import game.sets.sets_level01 -- hide\n\nnamespace xena -- hide\n\nopen_locale classical -- hide\n\nvariable X : Type -- hide\n\n/-\n# Chapter 1 : Sets\n\n## Level 2 : union (\u222a)\n-/\n\n/- \nWorking with sets is very similar to working with propositions.\nLet's now prove that any set $A$ is included in its union with \nany other set $B$, or $A \u2286 A \u222a B$. To work with unions you will\nneed to know the property which classifies them:\n\n```\nmem_union_iff : x \u2208 A \u222a B \u2194 x \u2208 A \u2228 x \u2208 B\n```\n\nYou need to get yourself into a situation where the left hand side\nof `mem_union_iff` is in your goal; that way, you can `rw mem_union_iff`\nand make progress.\n-/\n\n/- Axiom : mem_union_iff :\nx \u2208 A \u222a B \u2194 x \u2208 A \u2228 x \u2208 B\n-/\n\n/- Hint : Tactic tip : intros\n`intros` is like `intro` but can be used to introduce more than one\nthing at once. For example if your goal is `\u22a2 \u2200 (x : X), x \u2208 A \u2192 x \u2208 A \u222a B`\nthen `intros x hx` will do the same as `intro x, intro hx`.\n-/\n\n/- Hint : Stuck?\nWe start with a rewrite (see level 1).\nThen, after introducing your terms, you'll be able to pull off\nthe second rewrite. Finally, you'll need to prove the `left`\nside of an `or` goal.\n-/\n\n\n/- Lemma\nIf $A$ and $B$ are sets of any type $X$, then\n$$ A \\subseteq A\\cup B.$$ \n-/\ntheorem subset_union_left (A B : set X) : A \u2286 A \u222a B :=\nbegin\n", "proof": "  rw subset_iff,\n  intro h,\n  intro f,\n  left,\n  exact f,\n  ", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena --hide\n", "height": 6, "editorText": "sorry", "lineOffset": 53, "name": "subset_union_left", "statement": "(A B : set X) : A \u2286 A \u222a B"}, {"type": "lean", "content": "29", "hidden": true}]}, {"name": "", "problemIndex": 11, "objects": [{"type": "lean", "content": "30", "hidden": true}, {"type": "lean", "content": "31", "hidden": true}, {"type": "lean", "content": "32", "hidden": true}, {"type": "lean", "content": "33", "hidden": true}, {"type": "text", "content": "34"}, {"type": "text", "content": "35"}, {"type": "axiom", "content": "36", "name": "mem_inter_iff :", "sideBar": true}, {"type": "hint", "content": "37", "title": "38"}, {"type": "hint", "content": "39", "title": "40"}, {"type": "hint", "content": "41", "title": "42"}, {"type": "hint", "content": "43", "title": "44"}, {"type": "lemma", "text": "45", "lean": "theorem intersection_subset (A B : set X) : A \u2229 B \u2286 A  :=\n", "sideBar": true, "firstProofLineNumber": 62, "lastProofLineNumber": 69, "textBefore": "import game.sets.sets_level02 -- hide\n\nnamespace xena -- hide\n\nopen_locale classical -- hide\n\nvariable X : Type -- hide\n\n/-\n# Chapter 1 : Sets\n\n## Level 3 : intersection (\u2229)\n-/\n\n\n/- \nNow prove that for any two sets $A$ and $B$, $A \u2229 B \u2286 A$.\n   \nYou will need to rewrite the following term:\n\n```\nmem_inter_iff : x \u2208 A \u2229 B \u2194 x \u2208 A \u2227 x \u2208 B \n```\n-/\n\n/- Axiom : mem_inter_iff :\nx \u2208 A \u2229 B \u2194 x \u2208 A \u2227 x \u2208 B\n-/\n\n/- Hint : Stuck?\nYou need to start the same way as in the previous levels.\nTry and get yourself into a situation where you have a\n*hypothesis* `hAB : x \u2208 A \u2229 B` and then use `rw mem_inter_iff at hAB`. \n-/\n\n/- Hint: A note on `x \u2208 A \u2227 x \u2208 B \u2192 x \u2208 A`\nBy convention, \u2227 binds more tightly than \u2192\n(i.e. `x \u2208 A \u2227 x \u2208 B \u2192 x \u2208 A` means `(x \u2208 A \u2227 x \u2208 B) \u2192 x \u2208 A`)\n-/\n\n/- Hint : Reminder about `cases` \nThe `cases h with hP hQ` tactic turns `h : P \u2227 Q` into `hP : P` and `hQ : Q`\n-/\n\n/- Hint : The `tauto!` tactic\nThe `tauto!` tactic solves goals in propositional logic (i.e. problems where\nthe relevant hypotheses and goal just involve `\u2227`, `\u2228`, `\u00ac` and `\u2192` and\npropositions -- for example it could easily solve this goal:\n\n```\nh : P \u2227 Q\n\u22a2 P\n```\n-/\n\n/- Lemma\nIf $A$ and $B$ are sets of any type $X$, then\n$$ A \\cap B \\subseteq A.$$\n-/\ntheorem intersection_subset (A B : set X) : A \u2229 B \u2286 A  :=\nbegin\n", "proof": "  rw subset_iff,\n  intro h, -- or cases, assumption\n  intro j,\n  rw mem_inter_iff at j,\n  cases j with h,\n  exact h,\n\n  ", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena -- hide\n", "height": 8, "editorText": "sorry", "lineOffset": 61, "name": "intersection_subset", "statement": "(A B : set X) : A \u2229 B \u2286 A"}, {"type": "lean", "content": "46", "hidden": true}]}, {"name": "", "problemIndex": 10, "objects": [{"type": "lean", "content": "47", "hidden": true}, {"type": "lean", "content": "48", "hidden": true}, {"type": "lean", "content": "49", "hidden": true}, {"type": "lean", "content": "50", "hidden": true}, {"type": "text", "content": "51"}, {"type": "axiom", "content": "52", "name": "ext_iff :", "sideBar": true}, {"type": "text", "content": "53"}, {"type": "hint", "content": "54", "title": "55"}, {"type": "hint", "content": "56", "title": "57"}, {"type": "hint", "content": "58", "title": "59"}, {"type": "lemma", "text": "60", "lean": "theorem subset_iff_union_eq (A : set X) (B : set X) : A \u2286 B \u2194 B = A \u222a B := \n", "sideBar": true, "firstProofLineNumber": 83, "lastProofLineNumber": 98, "textBefore": "import game.sets.sets_level03 -- hide\n\nnamespace xena -- hide\n\nopen_locale classical -- hide\n\nvariable X : Type --hide\n\n/-\n# Chapter 1 : Sets\n\n## Level 4\n-/\n\n/- Axiom : ext_iff :\nA = B \u2194 \u2200 x : X, x \u2208 A \u2194 x \u2208 B\n-/\n\n/-\n\nTo prove that two sets are equal, one needs to use the axiom\nof extensionality: two sets are equal if and only if they have\nthe same elements.\n\nIn Lean's maths library this axiom is called `ext_iff`.\n\n```\nlemma ext_diff : A = B \u2194 \u2200 x : X, x \u2208 A \u2194 x \u2208 B\n```\n-/\n\n/- Hint: A word on coding style\n\nAfter a `split` statement, one goal turns into two. A good programming style\nwould be to use `{}` brackets to work on each goal individually, like this:\n```\nbegin\n  split,\n  { insert,\n    proof of,\n    first goal\n  },\n  { insert,\n    proof of,\n    second goal\n  }\nend\n```\n\nThis way you only ever have one goal to work on, and your code becomes\neasier to read. After `split` you might want to write \n```\n{ sorry},\n{ sorry}\n```\nso that your code has no errors while you're working on it.\n-/\n\n\n/- Hint : Stuck?\nTo prove the theorem below, remember that you can use `split` to \nchange the goal into two goals, corresponding to the left-right and\nright-left implication, respectively. For the first goal, after\n`intro h,` the equality of the two sets can be manipulated\nusing `rw ext_iff`.\n-/\n\n/- Hint: rewrite failures and the `simp_rw` tactic\n`rw` doesn't work \"under a binder\". In other words, if your goal is\n`\u22a2\t\u2200 (x : X), x \u2208 B \u2194 x \u2208 A \u222a B` then `rw mem_union_iff` won't work!\nIt's the `\u2200` which is blocking it. Either do `intro x` (and then\nthe `rw` will work), or use a more powerful rewrite tactic\ncalled `simp_rw`, which will work \n\n-/\n\n/- Lemma\nIf $A$ and $B$ are sets of any type $X$, then\n$$ A \\subseteq B \\iff A \\cup B = B.$$\n-/\ntheorem subset_iff_union_eq (A : set X) (B : set X) : A \u2286 B \u2194 B = A \u222a B := \nbegin\n", "proof": "  rw subset_iff,\n  split,\n  intro h,\n  rw ext_iff,\n  simp_rw mem_union_iff,\n  intro j,\n  specialize h j,\n  tauto!,\n\n  intro h,\n  intro k,\n  intro b,\n  rw h,\n  left,\n  exact b,\n", "proof_hint": "sorry", "textAfter": "\nend\n\n--begin hide\n-- theorem subset_iff_union_eq' (A : set X) (B : set X) : A \u2286 B \u2194 B = A \u222a B := \n-- begin\n--   rw subset_iff,\n--   rw ext_iff,\n--   apply forall_congr,\n--   intro x,\n--   rw mem_union_iff,\n--   tauto!,\n-- end\n--end hide\n\n\nend xena --hide\n\n\n\n--rw subset_iff,\n  --split,\n  --{ intro h,\n    --rw ext_iff,\n     -- can't rewrite under a binder\n    --simp_rw mem_union_iff,\n    --intro x,\n    --specialize h x, -- or replace h := h x,\n    --tauto! },\n  --{ intro h,\n    --intros x hA,\n    --rw h,\n    --rw mem_union_iff,\n    --tauto!\n  --}", "height": 16, "editorText": "sorry", "lineOffset": 82, "name": "subset_iff_union_eq", "statement": "(A : set X) (B : set X) : A \u2286 B \u2194 B = A \u222a B"}, {"type": "lean", "content": "61", "hidden": false}, {"type": "lean", "content": "62", "hidden": true}, {"type": "lean", "content": "63", "hidden": false}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "64", "hidden": true}, {"type": "lean", "content": "65", "hidden": true}, {"type": "lean", "content": "66", "hidden": true}, {"type": "lean", "content": "67", "hidden": true}, {"type": "text", "content": "68"}, {"type": "text", "content": "69"}, {"type": "lemma", "text": "70", "lean": "theorem subset_iff_inter_eq (A : set X) (B : set X) : A \u2286 B \u2194 A = A \u2229 B := \n", "sideBar": true, "firstProofLineNumber": 39, "lastProofLineNumber": 53, "textBefore": "import game.sets.sets_level04 -- hide\n\nnamespace xena -- hide\n\nopen_locale classical -- hide\n\nvariable X : Type --hide\n\n/-\n# Chapter 1 : Sets\n\n## Level 5\n-/\n\n\n/-\nIf `h : \u2200 (x : X), x \u2208 A \u2192 x \u2208 B` then `h` is a function which takes\na term `x` of type `X` as input, and also a proof that `x \u2208 A`, and outputs a\nproof that `x \u2208 B`. If you want to run this function `h` on some term `a : X`\nthen any of the following work:\n\n```\nhave h2 := h a,\nreplace h := h a,\nspecialize h a\n```\n\nThe first one preserves `h` and creates a new hypothesis `h2`. The others\nreplace `h` with `h : a \u2208 A \u2192 a \u2208 B`.\n-/\n\n/- Lemma\nIf $A$ and $B$ are sets of any type $X$, then\n$$ A \\subseteq B \\iff A \\cap B = A.$$\n-/\n\ntheorem subset_iff_inter_eq (A : set X) (B : set X) : A \u2286 B \u2194 A = A \u2229 B := \nbegin\n", "proof": "  rw subset_iff,\n  rw ext_iff,\n  split,\n  intro h,\n  intro j,\n  specialize h j,\n  simp_rw mem_inter_iff,\n  tauto!,\n\n  intro h,\n  intro j,\n  specialize h j,\n  simp_rw mem_inter_iff at h,\n  tauto!,\n  ", "proof_hint": "sorry", "textAfter": "\nend\n\n-- begin hide\n-- theorem subset_iff_intersection_eq' (A : set X) (B : set X) : A \u2286 B \u2194 A \u2229 B = A := \n-- begin\n--   rw subset_iff,\n--   rw eq_iff,\n--   apply forall_congr, -- clever trick\n--   intro x,\n--   rw mem_inter_iff, -- no longer under a binder\n--   tauto!\n-- end\n-- end hide\n\nend xena -- hide\n\n/-\nrw subset_iff,\n  rw ext_iff,\n  split,\n  { intros h x,\n    specialize h x,\n    rw mem_inter_iff,\n    tauto!\n  },\n  { intros h x hx,\n    specialize h x,\n    rw mem_inter_iff at h,\n    tauto!,\n  }\n  -/", "height": 15, "editorText": "sorry", "lineOffset": 38, "name": "subset_iff_inter_eq", "statement": "(A : set X) (B : set X) : A \u2286 B \u2194 A = A \u2229 B"}, {"type": "lean", "content": "71", "hidden": true}, {"type": "lean", "content": "72", "hidden": true}, {"type": "text", "content": "73"}]}, {"name": "", "problemIndex": 9, "objects": [{"type": "lean", "content": "74", "hidden": true}, {"type": "lean", "content": "75", "hidden": true}, {"type": "lean", "content": "76", "hidden": true}, {"type": "lean", "content": "77", "hidden": false}, {"type": "lean", "content": "78", "hidden": true}, {"type": "text", "content": "79"}, {"type": "text", "content": "80"}, {"type": "axiom", "content": "81", "name": "mem_sdiff_iff :", "sideBar": true}, {"type": "axiom", "content": "82", "name": "mem_neg_iff :", "sideBar": true}, {"type": "lemma", "text": "83", "lean": "theorem setdiff_eq_intersect_comp (A B : set X) : A \\ B = A \u2229 B\u1d9c := \n", "sideBar": true, "firstProofLineNumber": 53, "lastProofLineNumber": 57, "textBefore": "import game.sets.sets_level05 -- hide\nimport tactic -- hide\n\n\nnamespace xena -- hide\n\nvariable X : Type\n\nopen_locale classical -- hide\n\n/-\n# Chapter 1 : Sets\n\n## Level 6 : `sdiff` and `neg`\n-/\n\n/-\n\nThe set-theoretic difference `A \\ B` satisfies the following property:\n\n```\nlemma mem_sdiff_iff : x \u2208 A \\ B \u2194 x \u2208 A \u2227 x \u2209 B\n```\n\nThe complement `-A` of a set `A` (often denoted $A^c$ in textbooks)\nis all the elements of `X` which are not in `A`:\n\n```\nlemma mem_neg_iff : x \u2208 -A \u2194 x \u2209 A\n```\n\nIn this lemma, you might get a shock. The `rw` tactic is aggressive\nin the Real Number Game -- if after a rewrite the goal can be\nsolved by `refl`, then Lean will close the goal automatically.\n\n-/\n\n/- Axiom : mem_sdiff_iff :\nx \u2208 A \\ B \u2194 x \u2208 A \u2227 x \u2209 B\n-/\n\n/- Axiom : mem_neg_iff :\nx \u2208 -A \u2194 x \u2209 A\n-/\n\n/- Lemma\nIf $A$ and $B$ are sets with elements of type $X$, then\n\n$$(A \\setminus B) = A \\cap B^{c}.$$\n-/\ntheorem setdiff_eq_intersect_comp (A B : set X) : A \\ B = A \u2229 B\u1d9c := \nbegin\n", "proof": "  rw ext_iff,\n  intro h,\n  rw mem_sdiff_iff,\n  rw mem_inter_iff,\n  rw mem_neg_iff,", "proof_hint": "sorry", "textAfter": "\nend\n\n\nend xena -- hide\n\n\n\n/-\nrw ext_iff,\n  intro x,\n  rw mem_sdiff_iff,\n  rw mem_inter_iff,\n  rw mem_neg_iff,\n-/\n", "height": 5, "editorText": "sorry", "lineOffset": 52, "name": "setdiff_eq_intersect_comp", "statement": "(A B : set X) : A \\ B = A \u2229 B\u1d9c"}, {"type": "lean", "content": "84", "hidden": true}, {"type": "text", "content": "85"}]}, {"name": "", "problemIndex": 9, "objects": [{"type": "lean", "content": "86", "hidden": true}, {"type": "lean", "content": "87", "hidden": true}, {"type": "lean", "content": "88", "hidden": true}, {"type": "lean", "content": "89", "hidden": true}, {"type": "lean", "content": "90", "hidden": true}, {"type": "text", "content": "91"}, {"type": "text", "content": "92"}, {"type": "axiom", "content": "93", "name": "mem_empty_iff :", "sideBar": true}, {"type": "hint", "content": "94", "title": "95"}, {"type": "lemma", "text": "96", "lean": "theorem empty_set_subset (A : set X) : \u2205 \u2286 A :=\n", "sideBar": true, "firstProofLineNumber": 44, "lastProofLineNumber": 51, "textBefore": "import tactic --hide\n\nimport game.sets.sets_level06 -- hide\n\nvariable X : Type --hide\n\nopen_locale classical -- hide\n\nnamespace xena -- hide\n\n/-\n# Chapter 1 : Sets\n\n## Level 7 : The empty set\n-/\n\n/-\n\nThe way to handle the empty set is the following:\n\n```\nlemma mem_empty_iff (a : X) : a \u2208 (\u2205 : set X) \u2194 false\n```\n-/\n\n/- Axiom : mem_empty_iff :\na \u2208 (\u2205 : set X) \u2194 false\n-/\n\n/- Hint : Stuck?\nRemember that `exfalso` changes any goal to `false`. This can be\nconvenient if your hypotheses can prove `false`.\n\nAnother approach: if `hx : false` then `cases hx` will do a case\nsplit into every proof of false -- but there are no proofs of\nfalse! So there will be no cases left to do.\n-/\n\n/- Lemma\nThe empty set is a subset of any set $A$. \n-/\ntheorem empty_set_subset (A : set X) : \u2205 \u2286 A :=\nbegin\n", "proof": "  rw subset_iff,\n  intro h,\n  rw mem_empty_iff,\n  intro j,\n  exfalso,\n  exact j,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena\n\n\n\n/-\nrw subset_iff,\n  intros x hx,\n  exfalso,\n  rw mem_empty_iff at hx,\n  exact hx,\n\n-/", "height": 8, "editorText": "sorry", "lineOffset": 43, "name": "empty_set_subset", "statement": "(A : set X) : \u2205 \u2286 A"}, {"type": "lean", "content": "97", "hidden": false}, {"type": "text", "content": "98"}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "99", "hidden": true}, {"type": "text", "content": "100"}, {"type": "text", "content": "101"}, {"type": "axiom", "content": "102", "name": "mem_Icc_iff :", "sideBar": true}, {"type": "text", "content": "103"}, {"type": "lean", "content": "104", "hidden": false}, {"type": "lemma", "text": "105", "lean": "example : (2 : \u211d) \u2208 [(0 : \u211d), 5] := \n", "sideBar": false, "firstProofLineNumber": 55, "lastProofLineNumber": 57, "textBefore": "import kb_real_defs --hide\n\n/-\n# Chapter 1 : Sets\n\n## Level 8\n-/\n\n\n/- \nThis is a very basic example of working with intervals of real numbers in Lean.\nAn interval `[a, b]` that is closed at both endpoints $a$ and $b$ can be \nconstructed using `set.Icc a b`. For an open-closed interval `(a, b]`,\nthe notation\nis `set.Ioc a b`, etc. The usual closed-interval notation, using square\nbrackets, is used here as a wrapper around these definitions. We have\nthe following lemma:\n\n\n\n```\nmem_Icc_iff : x \u2208 Icc a b \u2194 a \u2264 x \u2227 x \u2264 b\n```\n-/\n\n/- Axiom : mem_Icc_iff :\nx \u2208 Icc a b \u2194 a \u2264 x \u2227 x \u2264 b\n-/\n\n/-\nAfter rewriting it, the `split` tactic will isolate the two conditions for \nmembership. Each inequality goals can be solved with the `norm_num` tactic,\nwhich closes goals which are equalities or inequalities between explicit\nreal numbers.\n-/\n\n/- Pro tip : semicolons\nIf instead of a comma, you end a line with a semicolon, then\nLean will apply the next tactic to all the goals created by the\nprevious tactic, rather than just the top one.\n-/\n\n/- Pro tip : definitional equality\n`mem_Icc_iff` is true by definition, so you don't actually\nhave to even rewrite it.\n-/\n\nnotation `[` a `,` b `]`  := set.Icc a b\n\n/- Lemma : no-side-bar\n$2 \u2208 [0,5]$\n-/\nexample : (2 : \u211d) \u2208 [(0 : \u211d), 5] := \nbegin\n", "proof": "    rw mem_Icc_iff,\n    split;\n    norm_num,", "proof_hint": "sorry", "textAfter": "\nend\n\n\n\n/-\nrw mem_Icc_iff,\n    split;\n    norm_num,\n-/", "height": 3, "editorText": "sorry", "lineOffset": 54, "name": "", "statement": "(2 : \u211d) \u2208 [(0 : \u211d), 5]"}, {"type": "text", "content": "106"}]}, {"name": "", "problemIndex": 4, "objects": [{"type": "lean", "content": "107", "hidden": false}, {"type": "text", "content": "108"}, {"type": "text", "content": "109"}, {"type": "lean", "content": "110", "hidden": false}, {"type": "lemma", "text": "111", "lean": "lemma zero_in_prod : (0:\u211d) \u2208 mem_prod_sets [(-2:\u211d), -1] [(0:\u211d), 3] :=\n", "sideBar": true, "firstProofLineNumber": 24, "lastProofLineNumber": 32, "textBefore": "import kb_real_defs\n\n/-\n# Chapter 1 : Sets\n\n## Level 9\n-/\n\n/- \nThis is a little more complicated example asking you to work with intervals of reals.\nThe result will be of help in the sup-inf world.\n-/\n\nnotation `[` a `,` b `]`  := set.Icc a b\n\ndef mem_prod_sets (A : set \u211d) (B : set \u211d) := { x : \u211d | \u2203 y \u2208 A, \u2203 z \u2208 B, x = y * z}\n\n\n/- Lemma\nIf $x = 0$, then `x \u2208 mem_prod_sets [(-2:\u211d),-1] [(0:\u211d), 3]`\n-/\nlemma zero_in_prod : (0:\u211d) \u2208 mem_prod_sets [(-2:\u211d), -1] [(0:\u211d), 3] :=\nbegin\n", "proof": "  rw mem_prod_sets,\n  dsimp,\n  use -2,\n  split,\n  norm_num,\n  use 0,\n  split,\n  norm_num,\n  norm_num,", "proof_hint": "sorry", "textAfter": "\nend\n\n\n\n\n/-\nrw mem_prod_sets,\n  dsimp,\n  use -2,\n  split, \n  { rw mem_Icc_iff,\n    split; linarith\n  },\n  use 0,\n  split,\n  { rw mem_Icc_iff,\n    split; linarith\n  },\n  norm_num\n-/\n", "height": 9, "editorText": "sorry", "lineOffset": 23, "name": "zero_in_prod", "statement": "(0:\u211d) \u2208 mem_prod_sets [(-2:\u211d), -1] [(0:\u211d), 3]"}, {"type": "text", "content": "112"}]}]}, {"name": "113", "levels": [{"name": "", "problemIndex": 3, "objects": [{"type": "lean", "content": "114", "hidden": false}, {"type": "lean", "content": "115", "hidden": true}, {"type": "text", "content": "116"}, {"type": "lemma", "text": "117", "lean": "theorem trichotomy' (a b : \u211d) : a < b \u2228 a = b \u2228 b < a :=\n", "sideBar": true, "firstProofLineNumber": 27, "lastProofLineNumber": 28, "textBefore": "import game.sets.sets_level10\nimport data.real.basic\n\nnamespace xena -- hide\n\n/-\n# Chapter 2 : Order\n\n## Level 1\n\nThis level aims to familiarize you with the use of the trichotomy property in \nLean, as it will come in handy in later levels.\nThis property is stated in Lean's mathlib is:\n\n`lt_trichotomy : \u2200 (a b : ?M_1), a < b \u2228 a = b \u2228 b < a`\n\nand you can just use it to finish the proof below.\n-/\n\n\n/- Lemma\nFor any two real numbers $a$ and $b$, we have that\n$$ a < b \\lor a = b \\lor b < a$$.\n-/\ntheorem trichotomy' (a b : \u211d) : a < b \u2228 a = b \u2228 b < a :=\nbegin\n", "proof": "    have j := lt_trichotomy a b,\n    exact j,", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena --hide\n", "height": 2, "editorText": "sorry", "lineOffset": 26, "name": "trichotomy'", "statement": "(a b : \u211d) : a < b \u2228 a = b \u2228 b < a"}, {"type": "lean", "content": "118", "hidden": true}]}, {"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "119", "hidden": false}, {"type": "lean", "content": "120", "hidden": true}, {"type": "text", "content": "121"}, {"type": "hint", "content": "122", "title": "123"}, {"type": "text", "content": "124"}, {"type": "hint", "content": "125", "title": "126"}, {"type": "lean", "content": "127", "hidden": false}, {"type": "lemma", "text": "128", "lean": "theorem abs_prod (a b : \u211d) : |a * b| = |a| * |b| :=\n", "sideBar": true, "firstProofLineNumber": 34, "lastProofLineNumber": 80, "textBefore": "import data.real.basic\nimport game.order.level01\n\nnamespace xena -- hide\n\n/-\n# Chapter 2 : Order\n\n## Level 2\n\nThis level invites you to work out a property of the absolute value.\nIn Lean the absolute value of $x$ is denoted by `abs x`. \n-/\n\n/- Hint : The definition of the absolute value in mathlib:\ndefinition abs {\u03b1 : Type u} [decidable_linear_ordered_add_comm_group \u03b1] (a : \u03b1) : \u03b1 := max a (-a)\n-/\n\n/-\nFor ease of use, a notation can be wrapped around that definition as below.\n-/\n\n/- Hint : Cases, Cases, Cases!\n-/\n\nnotation `|` x `|` := abs x\n\n/- Lemma\nFor any two real numbers $a$ and $b$, we have that\n$$|ab| = |a||b|$$.\n-/\ntheorem abs_prod (a b : \u211d) : |a * b| = |a| * |b| :=\nbegin\n", "proof": "    rcases lt_trichotomy a 0 with han | haz | hap,\n    swap,\n    have h : a * b = 0, norm_num,\n    left,\n    exact haz,\n    rw h,\n    rw haz,\n    norm_num,\n    rcases lt_trichotomy b 0 with hbn | hbz | hbp,\n    swap,\n    have h : a * b = 0, norm_num,\n    right,\n    exact hbz,\n    rw h,\n    rw hbz,\n    norm_num,\n    have h1 : 0 < a * b, exact mul_pos_of_neg_of_neg han hbn,\n    have h2 : | a * b | = a * b, exact abs_of_pos h1,\n    have h3 : | a | = - a, exact abs_of_neg han,\n    have h4 : | b | = - b, exact abs_of_neg hbn,\n    rw h2, rw h3, rw h4,\n    norm_num,\n    have h1 : a * b < 0, exact mul_neg_of_neg_of_pos han hbp,\n    have h2 : | a * b | = - (a * b), exact abs_of_neg h1,\n    have h3 : | a | = - a, exact abs_of_neg han,\n    have h4 : | b | = b, exact abs_of_pos hbp,\n    rw h2, rw h3, rw h4,\n    norm_num,\n    rcases lt_trichotomy b 0 with hbn | hbz | hbp,\n    swap,\n    have h : a * b = 0, norm_num,\n    right,\n    exact hbz,\n    rw h,\n    rw hbz,\n    norm_num,\n    have h1 : a * b < 0, exact mul_neg_of_pos_of_neg hap hbn,\n    have h2 : | a * b | = - (a * b), exact abs_of_neg h1,\n    have h3 : | a | = a, exact abs_of_pos hap,\n    have h4 : | b | = - b, exact abs_of_neg hbn,\n    rw [h2,h3,h4],\n    norm_num,\n    have h1 : 0 < a * b, exact mul_pos hap hbp,\n    have h2 : | a * b | = a * b, exact abs_of_pos h1,\n    have h3 : | a | = a, exact abs_of_pos hap,\n    have h4 : | b | = b, exact abs_of_pos hbp,\n    rw [h2,h3,h4],", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena --hide\n\n", "height": 47, "editorText": "sorry", "lineOffset": 33, "name": "abs_prod", "statement": "(a b : \u211d) : |a * b| = |a| * |b|"}, {"type": "lean", "content": "129", "hidden": true}]}, {"name": "", "problemIndex": 4, "objects": [{"type": "lean", "content": "130", "hidden": false}, {"type": "lean", "content": "131", "hidden": true}, {"type": "text", "content": "132"}, {"type": "lean", "content": "133", "hidden": true}, {"type": "lemma", "text": "134", "lean": "theorem abs_le (a c : \u211d) (h : 0 \u2264 c): |a| \u2264 c \u2194 (-c) \u2264 a \u2227 a \u2264 c :=\n", "sideBar": true, "firstProofLineNumber": 21, "lastProofLineNumber": 52, "textBefore": "import game.order.level02\n\nnamespace xena -- hide\n\n/-\n# Chapter 2 : Order\n\n## Level 3\n\nAnother property of the absolute value.\n-/\n\nnotation `|` x `|` := abs x --hide\n\n/- Lemma\nFor any two real numbers $a$ and $b$, we have that\n$$|a| \u2264 c \u2194 -c \u2264 a \u2264 c$$.\n-/\ntheorem abs_le (a c : \u211d) (h : 0 \u2264 c): |a| \u2264 c \u2194 (-c) \u2264 a \u2227 a \u2264 c :=\nbegin\n", "proof": "    split,\n    intro j,\n    rcases lt_trichotomy a 0 with han | haz | hap,\n    swap,\n    rw haz,\n    split,\n    linarith,\n    exact h,\n    split,\n    have h1 : | a | = - a, exact abs_of_neg han,\n    rw h1 at j,\n    linarith,\n    linarith,\n    split,\n    have h2 : | a | = a, exact abs_of_pos hap,\n    rw h2 at j,\n    linarith,\n    have h2 : | a | = a, exact abs_of_pos hap,\n    rw h2 at j,\n    exact j,\n    intro k,\n    cases k with d hd,\n    rcases lt_trichotomy a 0 with han | haz | hap,\n    have h1 : | a | = - a, exact abs_of_neg han,\n    rw h1,\n    linarith,\n    rw haz,\n    norm_num,\n    exact h,\n    have h1 : | a | = a, exact abs_of_pos hap,\n    rw h1,\n    linarith,", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena --hide\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/-\nsplit,\n    rcases lt_trichotomy a 0 with haNeg | haZero | haPos,\n    { -- case a < 0\n        intro H, \n        have h1 : | a | = - a, exact abs_of_neg haNeg,\n        rw h1 at H, split, linarith, linarith,\n    },\n    { -- case a = 0\n        intro H, rw haZero, split, linarith, exact h,\n    },\n    { -- case 0 < a\n        intro H,\n        have h1 : |a| = a, exact abs_of_pos haPos,\n        rw h1 at H, split, linarith, exact H,\n    },\n    \n    \n    rcases lt_trichotomy a 0 with haNeg | haZero | haPos,\n    { -- case a < 0\n        intro H, \n        have h1 : | a | = - a, exact abs_of_neg haNeg,\n        rw abs_le, \n        exact H,\n    },\n    { -- case a = 0\n        intro H,\n        rw abs_le, exact H,\n    },\n    { -- case 0 < a\n        intro H,\n        rw abs_le, exact H,\n    },\n    \n\n    done\n-/", "height": 32, "editorText": "sorry", "lineOffset": 20, "name": "abs_le", "statement": "(a c : \u211d) (h : 0 \u2264 c): |a| \u2264 c \u2194 (-c) \u2264 a \u2227 a \u2264 c"}, {"type": "lean", "content": "135", "hidden": true}, {"type": "text", "content": "136"}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "137", "hidden": false}, {"type": "lean", "content": "138", "hidden": true}, {"type": "text", "content": "139"}, {"type": "hint", "content": "140", "title": "141"}, {"type": "lean", "content": "142", "hidden": false}, {"type": "lemma", "text": "143", "lean": "theorem abs_sub_le_sum_abs (a b : \u211d) : |a - b| \u2264 |a| + |b| :=\n", "sideBar": true, "firstProofLineNumber": 31, "lastProofLineNumber": 38, "textBefore": "import game.order.level03\n\nnamespace xena -- hide\n\n/-\n# Chapter 2 : Order\n\n## Level 4\n\nThis level invites you to work out a property of the absolute value.\nIn Lean the absolute value of $x$ is denoted by `abs x`. \nFor ease of use, a notation can be used around that definition as below.\nFeel free to use the triangle inequality on the real numbers,\n\n`abs_add : \u2200 (a b : ?M_1), |a + b| \u2264 |a| + |b|`\n\ntogether with the `linarith` and `norm_num` tactics.\n-/\n\n/- Hint : a - b = a + (-b)\n-/\n\nnotation `|` x `|` := abs x\n\n/- Lemma\nFor any two real numbers $a$ and $b$, we have that\n$$| a - b| \u2264 |a| + |b|$$.\n-/\ntheorem abs_sub_le_sum_abs (a b : \u211d) : |a - b| \u2264 |a| + |b| :=\nbegin\n", "proof": "    have h : a - b = a + (-b),\n    linarith,\n    rw h,\n    have g := abs_add a (-b),\n    have j : abs (-b) = abs b,\n    norm_num,\n    rw j at g,\n    exact g,", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena --hide\n\n\n\n\n\n\n\n\n\n\n\n/-\nhave H : a - b = a + (-b), linarith,\n    rw H, \n    have G := abs_add a (-b),\n    have F : abs (-b) = abs b, norm_num,\n    rw F at G, exact G, done\n-/", "height": 8, "editorText": "sorry", "lineOffset": 30, "name": "abs_sub_le_sum_abs", "statement": "(a b : \u211d) : |a - b| \u2264 |a| + |b|"}, {"type": "lean", "content": "144", "hidden": true}, {"type": "text", "content": "145"}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "146", "hidden": false}, {"type": "lean", "content": "147", "hidden": true}, {"type": "text", "content": "148"}, {"type": "lean", "content": "149", "hidden": true}, {"type": "text", "content": "150"}, {"type": "lemma", "text": "151", "lean": "theorem abs_of_sub_le_abs (a b : \u211d) : | |a| - |b| | \u2264 |a - b| :=\n", "sideBar": true, "firstProofLineNumber": 27, "lastProofLineNumber": 57, "textBefore": "import game.order.level04\nimport game.order.H\n\nnamespace xena -- hide\n\n/-\n# Chapter 2 : Order\n\n## Level 5\n\nAnother well-known property of the absolute value.\n-/\n\nnotation `|` x `|` := abs x -- hide\n\n\n/-\nHint: negate abs_le_if_pos_neg_le\n-/\n\n/- Lemma\nFor any two real numbers $a$ and $b$, we have that\n$$| |a| - |b| | \u2264 |a - b|$$.\n-/\ntheorem abs_of_sub_le_abs (a b : \u211d) : | |a| - |b| | \u2264 |a - b| :=\nbegin\n", "proof": "    have h1 : a = (a - b) + b,\n    norm_num,\n    have h2 : | a | = | (a - b) + b |,\n    norm_num,\n    have h3 : | (a - b) + b | \u2264 |a - b| + |b|,\n    exact abs_add _ _,\n    rw \u2190 h2 at h3,\n    have h4 : | a | - | b | \u2264 | a - b |,\n    linarith,\n    have k1 : b = (b - a) + a,\n    norm_num,\n    have k2 : | b | = | (b - a) + a |,\n    norm_num,\n    have k3 : | (b - a) + a | \u2264 |b - a| + |a|,\n    exact abs_add _ _,\n    rw \u2190 k2 at k3,\n    have k4 : | b | - | a | \u2264 | b - a |,\n    linarith,\n    clear h1 h2 h3 k1 k2 k3,\n    have h := eq.symm (abs_neg (a-b)),\n    have h2 : -(a - b) = b - a,\n    norm_num,\n    rw h2 at h,\n    rw \u2190 h at k4,\n    have H := abs_le_if_pos_neg_le (|a| - |b|) (|a - b|),\n    apply H,\n    have G := abs_le_if_pos_neg_le(|b| - |a|) (|b - a|),\n    norm_num,\n    split,\n    exact h4,\n    exact k4,", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena --hide\n", "height": 31, "editorText": "sorry", "lineOffset": 26, "name": "abs_of_sub_le_abs", "statement": "(a b : \u211d) : | |a| - |b| | \u2264 |a - b|"}, {"type": "lean", "content": "152", "hidden": true}]}, {"name": "", "problemIndex": 4, "objects": [{"type": "lean", "content": "153", "hidden": false}, {"type": "lean", "content": "154", "hidden": true}, {"type": "text", "content": "155"}, {"type": "lean", "content": "156", "hidden": false}, {"type": "lemma", "text": "157", "lean": "theorem le_iff_sq_le (a b : \u211d) (ha : 0 \u2264 a) (hb : 0 \u2264 b): a \u2264 b \u2194 a^2 \u2264 b^2:=\n", "sideBar": true, "firstProofLineNumber": 33, "lastProofLineNumber": 64, "textBefore": "import game.order.level05\nimport data.real.basic\nopen real\n\nnamespace xena -- hide\n\n/-\n# Chapter 2 : Order\n\n## Level 6\n\nAn interesting result to prove.\n-/\n\n\n-- You will need to use lemma \n--mul_le_mul (hac : a \u2264 c) (hbd : b \u2264 d) (nn_b : 0 \u2264 b) (nn_c : 0 \u2264 c) : \n--a * b \u2264 c * d\n\n\n\ntheorem pow_nonneg {a : \u211d } (H : 0 \u2264 a) : \u2200 (n : \u2115), 0 \u2264 a ^ n\n| 0     := zero_le_one\n| (n+1) := mul_nonneg H (pow_nonneg _)\n\n\n/- Lemma\nFor any two non-negative real numbers $a$ and $b$, we have that\n$$a \\le b \\iff a^2 \\le b^2 $$.\n-/\ntheorem le_iff_sq_le (a b : \u211d) (ha : 0 \u2264 a) (hb : 0 \u2264 b): a \u2264 b \u2194 a^2 \u2264 b^2:=\nbegin\n", "proof": "    split,\n    intro h,\n    have h1 : a^2 \u2264 a * b,\n    have h11 : a \u2264 a,\n    linarith,\n    --hint next line\n    have h2 := mul_le_mul h11 h ha ha,\n    have h3 : a * a = a ^ 2,\n    ring,\n    rw h3 at h2,\n    exact h2,\n    have h5 : a * b \u2264 b ^ 2,\n    have h2 : b \u2264 b,\n    linarith,\n    have h4 := mul_le_mul h2 h ha hb,\n    rw mul_comm at h4,\n    have h6 : b * b = b ^ 2,\n    ring,\n    rw h6 at h4,\n    exact h4,\n\n    exact le_trans h1 h5,\n    intro j,\n   \n    have h1 : 0 \u2264 a ^ 2, exact pow_nonneg ha 2,\n    have h2 : 0 \u2264 b ^ 2, exact pow_nonneg hb 2,\n    have h3 := (sqrt_le h1 h2).2 j,\n    have h4 := sqrt_sqr ha, \n    have h5 := sqrt_sqr hb,\n    rw h4 at h3,\n    rw h5 at h3,\n    exact h3,", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena -- hide\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/-\nsplit,\n    intro h,\n    have h1 : a^2 \u2264 a * b, \n        have h11 : a \u2264 a, linarith,\n        have h12 := mul_le_mul h11 h ha ha,\n        have h13 : a * a = a^2, ring,\n        rw h13 at h12, exact h12,\n    have h2 : a * b \u2264 b^2, \n        have h21 : b \u2264 b, linarith,\n        have h22 := mul_le_mul h21 h ha hb,\n        rw mul_comm at h22,\n        have h23 : b * b = b^2, ring,\n        rw h23 at h22, exact h22,\n    exact le_trans h1 h2,\n    intro h,\n    have ha2 : 0 \u2264 a^2, exact pow_nonneg ha 2,\n    have hb2 : 0 \u2264 b^2, exact pow_nonneg hb 2,\n    have h1 := (sqrt_le ha2 hb2).mpr h,\n    have h2a := sqrt_sqr ha, \n    have h2b := sqrt_sqr hb,\n    rw h2a at h1, rw h2b at h1, exact h1, done\n-/", "height": 32, "editorText": "sorry", "lineOffset": 32, "name": "le_iff_sq_le", "statement": "(a b : \u211d) (ha : 0 \u2264 a) (hb : 0 \u2264 b): a \u2264 b \u2194 a^2 \u2264 b^2"}, {"type": "lean", "content": "158", "hidden": true}, {"type": "text", "content": "159"}]}, {"name": "", "problemIndex": 4, "objects": [{"type": "lean", "content": "160", "hidden": false}, {"type": "lean", "content": "161", "hidden": true}, {"type": "text", "content": "162"}, {"type": "axiom", "content": "163", "name": "irrational_sqrt_two : irrational (sqrt 2)", "sideBar": true}, {"type": "lemma", "text": "164", "lean": "theorem not_sum_irrational : \n    \u00ac ( \u2200 (a b : \u211d), irrational a \u2192  irrational b \u2192 irrational (a+b) ) :=\n", "sideBar": true, "firstProofLineNumber": 39, "lastProofLineNumber": 44, "textBefore": "import game.order.level06\nimport data.real.irrational\n\nopen real\n\nnamespace xena -- hide\n\n/-\n# Chapter 2 : Order\n\n## Level 7\n\nProve by example that there exist pairs of real numbers\n$a$ and $b$ such that $a \\in \\mathbb{R} \\setminus \\mathbb{Q}$, \n$b \\in \\mathbb{R} \\setminus \\mathbb{Q}$,\nbut their sum $a + b$ is a rational number, $(a+b) \\in \\mathbb{Q}$.\nYou may use this result in the Lean mathlib library:\n\n`irrational_sqrt_two : irrational (sqrt 2)`\n\n-/\n\n/- Axiom : irrational_sqrt_two : irrational (sqrt 2) \n\ntheorem irrational_neg_iff : irrational (-x) \u2194 irrational x \n\n.2 after irrational_neg_iff gives the left side of the biconditional\n\nexistsi in this case brings up 0 to the rational numbers.\n-/\n\n/- Lemma\nNot true that for any $a$, $b$, irrational numbers, the sum is \nalso an irrational number.\n-/\ntheorem not_sum_irrational : \n    \u00ac ( \u2200 (a b : \u211d), irrational a \u2192  irrational b \u2192 irrational (a+b) ) :=\nbegin\n", "proof": "  intro h,\n  have H := h (sqrt 2) (-sqrt 2),\n  have H3 := H irrational_sqrt_two (irrational_neg_iff.2 irrational_sqrt_two),\n  apply H3,\n  existsi (0 : \u211a),\n  simp,", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena -- hide\n\n", "height": 6, "editorText": "sorry", "lineOffset": 38, "name": "not_sum_irrational", "statement": "\u00ac ( \u2200 (a b : \u211d), irrational a \u2192  irrational b \u2192 irrational (a+b) )"}, {"type": "lean", "content": "165", "hidden": true}]}, {"name": "", "problemIndex": 3, "objects": [{"type": "lean", "content": "166", "hidden": false}, {"type": "lean", "content": "167", "hidden": true}, {"type": "text", "content": "168"}, {"type": "lemma", "text": "169", "lean": "theorem not_prod_irrational : \n    \u00ac ( \u2200 (a b : \u211d), irrational a \u2192  irrational b \u2192 irrational (a*b) ) :=\n", "sideBar": true, "firstProofLineNumber": 30, "lastProofLineNumber": 36, "textBefore": "import game.order.level07\nimport data.real.irrational\n\nopen real\n\nnamespace xena -- hide\n\n/-\n# Chapter 2 : Order\n\n## Level 8\n\nProve by example that there exist pairs of real numbers\n$a$ and $b$ such that $a \\in \\mathbb{R} \\setminus \\mathbb{Q}$, \n$b \\in \\mathbb{R} \\setminus \\mathbb{Q}$,\nbut their product $a \\cdot b$ is a rational number, $(a \\cdot b) \\in \\mathbb{Q}$.\nYou may use this result in the Lean mathlib library:\n\n`irrational_sqrt_two : irrational (sqrt 2)\n-/\n\n\n/- Lemma\nNot true that for any $a$, $b$, irrational numbers, the product is \nalso an irrational number.\n-/\ntheorem not_prod_irrational : \n    \u00ac ( \u2200 (a b : \u211d), irrational a \u2192  irrational b \u2192 irrational (a*b) ) :=\nbegin\n", "proof": "  intro h,\n  have h2 := h (sqrt 2) (sqrt 2),\n  have H3 := h2 irrational_sqrt_two irrational_sqrt_two,\n  apply H3,\n  existsi (2 : \u211a),\n  simp,\n  norm_num,", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena -- hide\n", "height": 7, "editorText": "sorry", "lineOffset": 29, "name": "not_prod_irrational", "statement": "\u00ac ( \u2200 (a b : \u211d), irrational a \u2192  irrational b \u2192 irrational (a*b) )"}, {"type": "lean", "content": "170", "hidden": true}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "171", "hidden": false}, {"type": "lean", "content": "172", "hidden": true}, {"type": "text", "content": "173"}, {"type": "lean", "content": "174", "hidden": false}, {"type": "lean", "content": "175", "hidden": true}, {"type": "lemma", "text": "176", "lean": "theorem abs_sub_eq_sum_abs (a b : \u211d) : |a + b| = |a| + |b| \u2194 a * b \u2265 0 :=\n", "sideBar": true, "firstProofLineNumber": 51, "lastProofLineNumber": 96, "textBefore": "import game.order.level08\nimport game.order.level02\nimport game.order.dumb\nimport game.order.lessdumb\nimport game.order.twocase\nopen real\n\nnamespace xena -- hide\n\n/-\n# Chapter 2 : Order\n\n## Level 9\n\nThis level invites you to work out a property of the absolute value.\nIn Lean the absolute value of $x$ is denoted by `abs x`. \nFor ease of use, a notation can be used around that definition as below.\nFeel free to use the triangle inequality on the real numbers,\n\n`abs_add : \u2200 (a b : ?M_1), |a + b| \u2264 |a| + |b|`\n\ntogether with the `linarith` and `norm_num` tactics.\n-/\n\nnotation `|` x `|` := abs x\n\n-- begin hide\n-- this to go in the side bar\nlemma eq_sqr_to_eq (a b : \u211d) (ha : 0 \u2264 a) (hb : 0 \u2264 b) : a^2 = b^2 \u2192 a = b :=\nbegin\n    intro h,\n    have h2 : sqrt (a ^ 2) = sqrt (a ^ 2),\n    refl,\n    --occurreneces.pos introduce\n    rw h at h2 {occs := occurrences.pos [2]},\n    have j := sqrt_sqr ha,\n    rw j at h2,\n    have k := sqrt_sqr hb,\n    rw k at h2,\n    exact h2,\n\nend\n-- end hide\n\n/- Lemma\nFor any two real numbers $a$ and $b$, we have that\n$$|a + b| = |a| + |b|$$ if and only if $ab \\ge 0$ .\n-/\ntheorem abs_sub_eq_sum_abs (a b : \u211d) : |a + b| = |a| + |b| \u2194 a * b \u2265 0 :=\nbegin\n", "proof": "    have H0 : (a+b)^2 = |a+b|^2, \n        have h01 := abs_mul_abs_self (a+b),\n        rw pow_two _, rw pow_two _, symmetry, exact h01,\n    have H1 : 0 \u2264 (a + b) ^ 2, exact pow_two_nonneg (a+b),\n    have H2 : (a+b) ^ 2 = a ^2 + 2 * a * b + b^2, ring,\n    have H3 : ( |a| + |b| )^2 = |a|^2 + 2*|a|*|b| + |b|^2, ring,\n    rw H0 at H2,\n    have Ha : a^2 = |a|^2, \n        have h01 := abs_mul_abs_self a,\n        rw pow_two _, rw pow_two _, symmetry, exact h01,\n    have Hb : b^2 = |b|^2, \n        have h01 := abs_mul_abs_self b,\n        rw pow_two _, rw pow_two _, symmetry, exact h01,\n    rw [Ha, Hb] at H2,\n\n    split,\n    intro j,\n    rw j at H2, rw H3 at H2, simp at H2,\n    rw mul_assoc at H2, rw mul_assoc at H2,\n    have g : (|a| * |b|) = (a * b),\n    linarith,\n    have g2 : |a * b| = |a| * |b|, exact abs_mul _ _,\n    rw \u2190 g2 at g,\n    by_contradiction hn, push_neg at hn,\n    have g3 : |a * b| = -(a * b),\n    exact abs_of_neg hn,\n    rw g at g3, linarith,\n\n    --add hints and comments and stuff\n    intro k,\n    have g : |a * b| = a * b,\n    exact abs_of_nonneg k,\n    have g2 : |a * b| = |a| * |b|,\n    exact abs_mul _ _,\n    rw g2 at g, rw mul_assoc 2 a b at H2,\n    rw \u2190 g at H2,\n    have g3 : |a| ^ 2 + 2 * ( |a| * |b| ) + |b| ^ 2 = ( |a| + |b| )^2, ring,\n    rw g3 at H2,\n    have g4 : sqrt ( |a + b| ^ 2 ) = sqrt ( |a + b| ^ 2), refl,\n    rw H2 at g4 {occs := occurrences.pos [2]},\n    have hab : 0 \u2264 |a + b|,  exact is_absolute_value.abv_nonneg abs (a+b),\n    have ha : 0 \u2264 |a|,  exact is_absolute_value.abv_nonneg abs a,\n    have hb : 0 \u2264 |b|,  exact is_absolute_value.abv_nonneg abs b,\n    have hc : 0 \u2264 |a| + |b|, linarith,\n    have G := eq_sqr_to_eq ( |a + b| ) ( |a| + |b| ) hab hc H2, exact G,\n    ", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena -- hide\n\n\n\n/-\nhave g : |a * b| = a * b,\n    exact abs_of_nonneg k,\n    have g2 : |a * b| = |a| * |b|,\n    exact abs_mul _ _,\n    rw g2 at g, rw mul_assoc 2 a b at H2,\n    rw \u2190 g at H2,\n    have g3 : |a| ^ 2 + 2 * ( |a| * |b| ) + |b| ^ 2 = ( |a| + |b| )^2, ring,\n    rw g3 at H2,\n    have g4 : sqrt ( |a + b| ^ 2 ) = sqrt ( |a + b| ^ 2), refl,\n    rw H2 at g4 {occs := occurrences.pos [2]},\n    have hab : 0 \u2264 |a + b|,  exact is_absolute_value.abv_nonneg abs (a+b),\n    have ha : 0 \u2264 |a|,  exact is_absolute_value.abv_nonneg abs a,\n    have hb : 0 \u2264 |b|,  exact is_absolute_value.abv_nonneg abs b,\n    have hc : 0 \u2264 |a| + |b|, linarith,\n    have G := eq_sqr_to_eq ( |a + b| ) ( |a| + |b| ) hab hc H2, exact G,\n\n\n    have g := abs_prod_eq_prod_iff_prod_nonneg a b,\n    intro k,\n    simp at k,\n    revert k,\n    rw g,\n    intro k,\n    have l := prod_nonneg_iff_eq_sign a b,\n    have p := reallydumb a b,\n    rw p,\n    have ha : 0 \u2264 |a|,  exact is_absolute_value.abv_nonneg abs a,\n    have hb : 0 \u2264 |b|,  exact is_absolute_value.abv_nonneg abs b,\n-/\n\n\n\n\n\n\n\n\n/-\nhave H0 : (a+b)^2 = |a+b|^2, \n        have h01 := abs_mul_abs_self (a+b),\n        rw pow_two _, rw pow_two _, symmetry, exact h01,\n    have H1 : 0 \u2264 (a + b) ^ 2, exact pow_two_nonneg (a+b),\n    have H2 : (a+b) ^ 2 = a ^2 + 2 * a * b + b^2, ring,\n    have H3 : ( |a| + |b| )^2 = |a|^2 + 2*|a|*|b| + |b|^2, ring,\n    rw H0 at H2,\n    have Ha : a^2 = |a|^2, \n        have h01 := abs_mul_abs_self a,\n        rw pow_two _, rw pow_two _, symmetry, exact h01,\n    have Hb : b^2 = |b|^2, \n        have h01 := abs_mul_abs_self b,\n        rw pow_two _, rw pow_two _, symmetry, exact h01,\n    rw [Ha, Hb] at H2,\n    split,\n    intro h,\n    rw h at H2, rw H3 at H2, simp at H2, \n    rw mul_assoc at H2, rw mul_assoc at H2,\n    have g1 : ( |a| * |b| ) = (a * b), linarith,\n    have g2 : |a * b| = ( |a| * |b| ), exact abs_mul _ _, \n    rw \u2190 g2 at g1,\n    by_contradiction hn, push_neg at hn,\n    have g3 : | a * b | = - (a *b), exact abs_of_neg hn,\n    rw g1 at g3, linarith,\n    -- the right-left direction\n    intro h,\n    have g1 : |a * b| = a * b, exact abs_of_nonneg h,\n    have g2 : |a * b| = ( |a| * |b| ), exact abs_mul _ _,\n    rw g2 at g1, rw mul_assoc 2 a b at H2,\n    rw \u2190 g1 at H2,\n    have g3 : |a| ^ 2 + 2 * ( |a| * |b| ) + |b| ^ 2 = ( |a| + |b| )^2, ring,\n    rw g3 at H2,\n    have g4 : sqrt ( |a + b| ^ 2 ) = sqrt ( |a + b| ^ 2), refl,\n    rw H2 at g4 {occs := occurrences.pos [2]},\n    have hab : 0 \u2264 |a + b|,  exact is_absolute_value.abv_nonneg abs (a+b),\n    have ha : 0 \u2264 |a|,  exact is_absolute_value.abv_nonneg abs a,\n    have hb : 0 \u2264 |b|,  exact is_absolute_value.abv_nonneg abs b,\n    have hc : 0 \u2264 |a| + |b|, linarith,\n    have G := eq_sqr_to_eq ( |a + b| ) ( |a| + |b| ) hab hc H2, exact G, done\n-/", "height": 46, "editorText": "sorry", "lineOffset": 50, "name": "abs_sub_eq_sum_abs", "statement": "(a b : \u211d) : |a + b| = |a| + |b| \u2194 a * b \u2265 0"}, {"type": "lean", "content": "177", "hidden": true}, {"type": "text", "content": "178"}, {"type": "text", "content": "179"}]}], "parents": [0]}, {"name": "180", "levels": [{"name": "", "problemIndex": -1, "objects": [{"type": "lean", "content": "181", "hidden": false}]}], "parents": [0]}, {"name": "182", "levels": [{"name": "", "problemIndex": 22, "objects": [{"type": "lean", "content": "183", "hidden": true}, {"type": "lean", "content": "184", "hidden": false}, {"type": "text", "content": "185"}, {"type": "lean", "content": "186", "hidden": false}, {"type": "text", "content": "187"}, {"type": "lean", "content": "188", "hidden": false}, {"type": "lean", "content": "189", "hidden": true}, {"type": "lean", "content": "190", "hidden": false}, {"type": "text", "content": "191"}, {"type": "axiom", "content": "192", "name": "le_refl a : a \u2264 a", "sideBar": true}, {"type": "axiom", "content": "193", "name": "le_trans : a \u2264 b \u2192 b \u2264 c \u2192 a \u2264 c", "sideBar": true}, {"type": "axiom", "content": "194", "name": "le_antisymm : a \u2264 b \u2192 b \u2264 a \u2192 a = b", "sideBar": true}, {"type": "axiom", "content": "195", "name": "le_total a b : a \u2264 b \u2228 b \u2264 a", "sideBar": true}, {"type": "axiom", "content": "196", "name": "lt_iff_le_and_ne : a < b \u2194 a \u2264 b \u2227 a \u2260 b", "sideBar": true}, {"type": "axiom", "content": "197", "name": "lt_of_le_of_lt : a \u2264 b \u2192 b < c \u2192 a < c", "sideBar": true}, {"type": "axiom", "content": "198", "name": "lt_of_lt_of_le : a < b \u2192 b \u2264 c \u2192 a < c", "sideBar": true}, {"type": "text", "content": "199"}, {"type": "axiom", "content": "200", "name": "max_eq_right : a \u2264 b \u2192 max a b = b", "sideBar": true}, {"type": "axiom", "content": "201", "name": "max_eq_left : b \u2264 a \u2192 max a b = a", "sideBar": true}, {"type": "lean", "content": "202", "hidden": true}, {"type": "text", "content": "203"}, {"type": "hint", "content": "204", "title": "205"}, {"type": "lemma", "text": "206", "lean": "theorem max_choice (a b : \u211d) : max a b = a \u2228 max a b = b :=\n", "sideBar": true, "firstProofLineNumber": 120, "lastProofLineNumber": 124, "textBefore": "import tactic -- hide\n\nimport data.real.basic -- imports the real numbers\n/-\n\n-/\nopen_locale classical -- allow proofs by contradiction\n/-\n\n-/\nnoncomputable theory -- don't fuss about the reals being noncomputable\n\nnamespace xena -- hide\n\n-- Let a, b, c be real numbers\nvariables {a b c : \u211d}\n\n/-\n# Chapter ? : Max and abs\n\n## Level 1\n\nIn this chapter we develop a basic interface for the `max a b` and `abs a`\nfunction on the real numbers. Before we start, you will need to know\nthe basic API for `\u2264` and `<`, which looks like this:\n\n```\nexample : a \u2264 a := le_refl a\n\nexample : a \u2264 b \u2192 b \u2264 c \u2192 a \u2264 c := le_trans\n\nexample : a \u2264 b \u2192 b \u2264 a \u2192 a = b := le_antisymm\n\nexample : a \u2264 b \u2228 b \u2264 a := le_total a b\n\nexample : a < b \u2194 a \u2264 b \u2227 a \u2260 b := lt_iff_le_and_ne\n\nexample : a \u2264 b \u2192 b < c \u2192 a < c := lt_of_le_of_lt\n\nexample : a < b \u2192 b \u2264 c \u2192 a < c := lt_of_lt_of_le\n```\n-/\n\n/- Axiom : le_refl a : a \u2264 a\n-/\n\n/- Axiom : le_trans : a \u2264 b \u2192 b \u2264 c \u2192 a \u2264 c\n-/\n\n/- Axiom : le_antisymm : a \u2264 b \u2192 b \u2264 a \u2192 a = b\n-/\n\n/- Axiom : le_total a b : a \u2264 b \u2228 b \u2264 a\n-/\n\n/- Axiom : lt_iff_le_and_ne : a < b \u2194 a \u2264 b \u2227 a \u2260 b\n-/\n\n/- Axiom : lt_of_le_of_lt : a \u2264 b \u2192 b < c \u2192 a < c \n-/\n\n/- Axiom : lt_of_lt_of_le : a < b \u2192 b \u2264 c \u2192 a < c\n-/\n\n/-\nWe start with `max a b := if a \u2264 b then b else a`. It is\nuniquely characterised by the following two properties, which are hence\nall you will need to know:\n\n```\ntheorem max_eq_right : a \u2264 b \u2192 max a b = b\n\ntheorem max_eq_left : b \u2264 a \u2192 max a b = a\n```\n-/\n\n/- Axiom : max_eq_right : a \u2264 b \u2192 max a b = b\n-/\n\n/- Axiom : max_eq_left : b \u2264 a \u2192 max a b = a\n-/\n\n-- begin hide\ndef max (a b : \u211d) := if a \u2264 b then b else a\n\n-- need if_pos to do this one\ntheorem max_eq_right (hab : a \u2264 b) : max a b = b :=\nbegin\n  rw max, \n  rw if_pos hab,\nend\n\n-- need if_neg to do this one\ntheorem max_eq_left (hba : b \u2264 a) : max a b = a :=\nbegin\n  by_cases hab : a \u2264 b,\n  rw max_eq_right hab,\n  exact le_antisymm hba hab,\n  rw max,\n  rw if_neg hab,\nend\n-- end hide\n\n\n/-\nAll of these theorems are in the theorem statement box on the left.\nSee if you can now prove the useful `max_choice` lemma using them.\n-/\n\n/- Hint : Hint\nDo a case split with `cases le_total a b`. \n-/\n\n/- Lemma\nFor any two real numbers $a$ and $b$, either $\\max(a,b) = a$\nor $\\max(a,b) = b$.\n-/\ntheorem max_choice (a b : \u211d) : max a b = a \u2228 max a b = b :=\nbegin\n", "proof": " cases le_total a b with hab hba,\n right,\n exact max_eq_right hab,\n left,\n exact max_eq_left hba,", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena --hide\n", "height": 5, "editorText": "sorry", "lineOffset": 119, "name": "max_choice", "statement": "(a b : \u211d) : max a b = a \u2228 max a b = b"}, {"type": "lean", "content": "207", "hidden": true}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "208", "hidden": true}, {"type": "lean", "content": "209", "hidden": true}, {"type": "lean", "content": "210", "hidden": true}, {"type": "lean", "content": "211", "hidden": true}, {"type": "text", "content": "212"}, {"type": "hint", "content": "213", "title": "214"}, {"type": "lemma", "text": "215", "lean": "theorem max_comm (a b : \u211d) : max a b = max b a :=\n", "sideBar": true, "firstProofLineNumber": 26, "lastProofLineNumber": 29, "textBefore": "import game.max.level01 -- hide\n\nopen_locale classical -- hide\n\nnoncomputable theory -- hide\n\nnamespace xena -- hide\n\n/-\n# Chapter ? : Max and abs\n\n## Level 2\n\n`max_comm` is the statement that `max a b = max b a`. See if you can prove it.\n-/\n\n/- Hint : Hint\nAgain, do a case split with `cases le_total a b`. \n-/\n\n/- Lemma\nFor any real numbers $a$ and $b$, we have $\\max(a,b) = \\max(b,a).$\n-/\ntheorem max_comm (a b : \u211d) : max a b = max b a :=\nbegin\n", "proof": "  cases le_total a b with h h;\n  rw max_eq_right h; \n  rw max_eq_left h,\n  ", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena --hide\n", "height": 4, "editorText": "sorry", "lineOffset": 25, "name": "max_comm", "statement": "(a b : \u211d) : max a b = max b a"}, {"type": "lean", "content": "216", "hidden": true}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "217", "hidden": true}, {"type": "lean", "content": "218", "hidden": true}, {"type": "lean", "content": "219", "hidden": true}, {"type": "lean", "content": "220", "hidden": true}, {"type": "text", "content": "221"}, {"type": "lemma", "text": "222", "lean": "theorem le_max_left (a b : \u211d) : a \u2264 max a b :=\n", "sideBar": true, "firstProofLineNumber": 27, "lastProofLineNumber": 32, "textBefore": "import game.max.level02 -- hide\n\nopen_locale classical -- hide\n\nnoncomputable theory -- hide\n\nnamespace xena -- hide\n\n/-\n# Chapter ? : Max and abs\n\n## Level 3\n\n`le_max_left` is the statement that `a \u2264 max a b`.\n\nTechnical note: in contrast to the natural number game, the `rw` used\nin the real number game is Lean's more powerful `rw`, which automatically\ntries `refl` after a rewrite; note that `\u2264` is reflexive, so `refl` will\nclose a goal of the form `a \u2264 a`. \n-/\n\n/- Lemma\nFor any real numbers $a$ and $b$, we have $a\\leq\\max(a,b).$\n-/\ntheorem le_max_left (a b : \u211d) : a \u2264 max a b :=\nbegin\n", "proof": "  cases le_total a b with hab hba,\n  rw max_eq_right hab,\n  exact hab,\n  rw max_eq_left hba,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena --hide\n", "height": 6, "editorText": "sorry", "lineOffset": 26, "name": "le_max_left", "statement": "(a b : \u211d) : a \u2264 max a b"}, {"type": "lean", "content": "223", "hidden": true}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "224", "hidden": true}, {"type": "lean", "content": "225", "hidden": true}, {"type": "lean", "content": "226", "hidden": true}, {"type": "lean", "content": "227", "hidden": true}, {"type": "text", "content": "228"}, {"type": "hint", "content": "229", "title": "230"}, {"type": "lemma", "text": "231", "lean": "theorem le_max_right (a b : \u211d) : b \u2264 max a b :=\n", "sideBar": true, "firstProofLineNumber": 28, "lastProofLineNumber": 29, "textBefore": "import game.max.level03 -- hide\n\nopen_locale classical -- hide\n\nnoncomputable theory -- hide\n\nnamespace xena -- hide\n\n/-\n# Chapter ? : Max and abs\n\n## Level 4\n\n`le_max_right` is the statement that `b \u2264 max a b`. There's a short\nproof using what we've already done.\n-/\n\n/- Hint : \nWhy not start with `rw max_comm`?\n-/\n\n/- Lemma\nFor any real numbers $a$ and $b$, we have $b\\leq\\max(a,b).$\n-/\n\ntheorem le_max_right (a b : \u211d) : b \u2264 max a b :=\nbegin\n", "proof": "  rw max_comm,\n  apply le_max_left,", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena --hide\n", "height": 2, "editorText": "sorry", "lineOffset": 27, "name": "le_max_right", "statement": "(a b : \u211d) : b \u2264 max a b"}, {"type": "lean", "content": "232", "hidden": true}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "233", "hidden": true}, {"type": "lean", "content": "234", "hidden": true}, {"type": "lean", "content": "235", "hidden": true}, {"type": "lean", "content": "236", "hidden": true}, {"type": "text", "content": "237"}, {"type": "lemma", "text": "238", "lean": "theorem max_le {a b c : \u211d} (hac : a \u2264 c) (hbc : b \u2264 c) : max a b \u2264 c :=\n", "sideBar": true, "firstProofLineNumber": 27, "lastProofLineNumber": 31, "textBefore": "import game.max.level04 -- hide\n\nopen_locale classical -- hide\n\nnoncomputable theory -- hide\n\nnamespace xena -- hide\n\n/-\n# Chapter ? : Max and abs\n\n## Level 5\n\n`max_le` is really useful; it says that if `a \u2264 c` and `b \u2264 c`\nthen `max a b \u2264 c`.\n\nNote that in the Lean formulation, the variables are *implicit*,\nmeaning that Lean will guess them.\n-/\n\n/- Lemma\nIf $a$, $b$, $c$ are real numbers with $a\\leq c$ and $b\\leq c$,\nthen $\\max(a,b)\\leq c.$\n-/\ntheorem max_le {a b c : \u211d} (hac : a \u2264 c) (hbc : b \u2264 c) : max a b \u2264 c :=\nbegin\n", "proof": "  cases max_choice a b with ha hb,\n  rw ha,\n  exact hac,\n  rw hb,\n  exact hbc,", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena --hide\n", "height": 5, "editorText": "sorry", "lineOffset": 26, "name": "max_le", "statement": "{a b c : \u211d} (hac : a \u2264 c) (hbc : b \u2264 c) : max a b \u2264 c"}, {"type": "lean", "content": "239", "hidden": true}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "240", "hidden": true}, {"type": "lean", "content": "241", "hidden": true}, {"type": "lean", "content": "242", "hidden": true}, {"type": "lean", "content": "243", "hidden": true}, {"type": "text", "content": "244"}, {"type": "hint", "content": "245", "title": "246"}, {"type": "lemma", "text": "247", "lean": "theorem max_le_iff {a b c : \u211d} : a \u2264 c \u2227 b \u2264 c \u2194 max a b \u2264 c :=\n", "sideBar": true, "firstProofLineNumber": 45, "lastProofLineNumber": 55, "textBefore": "import game.max.level05 -- hide\n\nopen_locale classical -- hide\n\nnoncomputable theory -- hide\n\nnamespace xena -- hide\n\n/-\n# Chapter ? : Max and abs\n\n## Level 6\n\nIn fact `max_le` can be beefed up to an iff statement.\n-/\n\n/- Hint : Tip : using `le_trans` \nIf your goal is `x \u2264 z` and you have a hypothesis `h : y \u2264 z`\nthen of course it will suffice to prove `x \u2264 y` and then you\ncan use transitivity. Instead of `have hxy : x \u2264 y,`, opening\na new goal and adding a new hypothesis to our list, you can\ndo \n\n```\napply le_trans _ h\n```\n\nor\n\n```\nrefine le_trans _ h\n```\n\nand this just reduces the goal to proving `x \u2264 y` immediately. \n\n-/\n\n/- Lemma\nIf $a$, $b$, $c$ are real numbers,\nthen ($a\\leq c$ and $b\\leq c$) iff $\\max(a,b)\\leq c.$\n-/\n\ntheorem max_le_iff {a b c : \u211d} : a \u2264 c \u2227 b \u2264 c \u2194 max a b \u2264 c :=\nbegin\n", "proof": "  split,\n  intro h,\n  cases h with t ht,\n  exact max_le t ht,\n  intro j,\n  split,\n  apply le_trans _ j,\n  apply le_max_left,\n  apply le_trans _ j,\n  apply le_max_right,\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena --hide\n\n/- Hint : Solution\n  split,\n  { intro h,\n    cases h with hac hbc,\n    exact max_le hac hbc\n  },\n  { intro habc,\n    split,\n    { apply le_trans _ habc,\n      apply le_max_left},\n    { apply le_trans _ habc,\n      apply le_max_right\n    }\n  }\n-/\n", "height": 11, "editorText": "sorry", "lineOffset": 44, "name": "max_le_iff", "statement": "{a b c : \u211d} : a \u2264 c \u2227 b \u2264 c \u2194 max a b \u2264 c"}, {"type": "lean", "content": "248", "hidden": true}, {"type": "hint", "content": "249", "title": "250"}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "251", "hidden": true}, {"type": "lean", "content": "252", "hidden": true}, {"type": "lean", "content": "253", "hidden": true}, {"type": "lean", "content": "254", "hidden": true}, {"type": "text", "content": "255"}, {"type": "lemma", "text": "256", "lean": "theorem max_lt {a b c : \u211d} (hac : a < c) (hbc : b < c) : max a b < c :=\n", "sideBar": true, "firstProofLineNumber": 24, "lastProofLineNumber": 29, "textBefore": "import game.max.level06 -- hide\n\nopen_locale classical -- hide\n\nnoncomputable theory -- hide\n\nnamespace xena -- hide\n\n/-\n# Chapter ? : Max and abs\n\n## Level 7\n\n`max_lt` and `max_lt_iff` are equally useful. Let's knock them off\nusing the same techniques.\n-/\n\n/- Lemma\nIf $a$, $b$, $c$ are real numbers with $a<c$ and $b<c$,\nthen $\\max(a,b)<c.$\n-/\ntheorem max_lt {a b c : \u211d} (hac : a < c) (hbc : b < c) : max a b < c :=\nbegin\n", "proof": "  cases max_choice a b with ha hb,\n  rw ha,\n  exact hac,\n  rw hb,\n  exact hbc,\n  ", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena --hide\n", "height": 6, "editorText": "sorry", "lineOffset": 23, "name": "max_lt", "statement": "{a b c : \u211d} (hac : a < c) (hbc : b < c) : max a b < c"}, {"type": "lean", "content": "257", "hidden": true}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "258", "hidden": true}, {"type": "lean", "content": "259", "hidden": true}, {"type": "lean", "content": "260", "hidden": true}, {"type": "lean", "content": "261", "hidden": true}, {"type": "text", "content": "262"}, {"type": "lemma", "text": "263", "lean": "theorem max_lt_iff {a b c : \u211d} : a < c \u2227 b < c \u2194 max a b < c :=\n", "sideBar": true, "firstProofLineNumber": 27, "lastProofLineNumber": 36, "textBefore": "import game.max.level07 -- hide\n\nopen_locale classical -- hide\n\nnoncomputable theory -- hide\n\nnamespace xena -- hide\n\n/-\n# Chapter ? : Max and abs\n\n## Level 8\n\nSee if you can do `max_lt_iff` without introducing\nany auxiliary hypotheses with `have`. Don't forget to\ncheck the list of theorems to see the interface for `\u2264`\nand `<`.\n-/\n\n/- Lemma\nIf $a$, $b$, $c$ are real numbers,\nthen ($a<c$ and $b<c$) iff $\\max(a,b)<c.$\n-/\n\ntheorem max_lt_iff {a b c : \u211d} : a < c \u2227 b < c \u2194 max a b < c :=\nbegin\n", "proof": "  split,\n  intro h,\n  cases h with t ht,\n  exact max_lt t ht,\n  intro j,\n  split,\n  apply lt_of_le_of_lt _ j,\n  apply le_max_left,\n  apply lt_of_le_of_lt _ j,\n  apply le_max_right,", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena --hide\n", "height": 10, "editorText": "sorry", "lineOffset": 26, "name": "max_lt_iff", "statement": "{a b c : \u211d} : a < c \u2227 b < c \u2194 max a b < c"}, {"type": "lean", "content": "264", "hidden": true}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "265", "hidden": true}, {"type": "lean", "content": "266", "hidden": true}, {"type": "lean", "content": "267", "hidden": true}, {"type": "lean", "content": "268", "hidden": true}, {"type": "text", "content": "269"}, {"type": "lemma", "text": "270", "lean": "theorem le_max_iff {a b c : \u211d} : a \u2264 max b c \u2194 a \u2264 b \u2228 a \u2264 c :=\n", "sideBar": true, "firstProofLineNumber": 24, "lastProofLineNumber": 41, "textBefore": "import game.max.level08 -- hide\n\nopen_locale classical -- hide\n\nnoncomputable theory -- hide\n\nnamespace xena -- hide\n\n/-\n# Chapter ? : Max\n\n## Level 9\n\nWe've done `max_le_iff`; here is `le_max_iff`. \n-/\n\n/- Lemma\nIf $a$, $b$, $c$ are real numbers,\nthen $a\\leq\\max(b,c)$ iff ($a\\leq b$ or $a\\leq c$).\n-/\n\ntheorem le_max_iff {a b c : \u211d} : a \u2264 max b c \u2194 a \u2264 b \u2228 a \u2264 c :=\nbegin\n", "proof": "  split,\n  intro h,\n  cases le_total b c with hbc hcb,\n  rw max_eq_right at h,\n  right,\n  exact h,\n  exact hbc,\n  rw max_eq_left at h,\n  left,\n  exact h,\n  exact hcb,\n  intro j,\n  cases j with d hd,\n  apply le_trans d,\n  apply le_max_left,\n  apply le_trans hd,\n  apply le_max_right,\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena --hide\n", "height": 18, "editorText": "sorry", "lineOffset": 23, "name": "le_max_iff", "statement": "{a b c : \u211d} : a \u2264 max b c \u2194 a \u2264 b \u2228 a \u2264 c"}, {"type": "lean", "content": "271", "hidden": true}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "272", "hidden": true}, {"type": "lean", "content": "273", "hidden": true}, {"type": "lean", "content": "274", "hidden": true}, {"type": "lean", "content": "275", "hidden": true}, {"type": "text", "content": "276"}, {"type": "lemma", "text": "277", "lean": "theorem lt_max_iff {a b c : \u211d} : a < max b c \u2194 a < b \u2228 a < c :=\n", "sideBar": true, "firstProofLineNumber": 24, "lastProofLineNumber": 41, "textBefore": "import game.max.level09 -- hide\n\nopen_locale classical -- hide\n\nnoncomputable theory -- hide\n\nnamespace xena -- hide\n\n/-\n# Chapter ? : Max\n\n## Level 10\n\nAnd finally `lt_max_iff`. \n-/\n\n/- Lemma\nIf $a$, $b$, $c$ are real numbers,\nthen $a<\\max(b,c)$ iff ($a<b$ or $a<c$).\n-/\n\ntheorem lt_max_iff {a b c : \u211d} : a < max b c \u2194 a < b \u2228 a < c :=\nbegin\n", "proof": "  split,\n  intro h,\n  cases le_total b c with hbc hcb,\n  rw max_eq_right at h,\n  right,\n  exact h,\n  exact hbc,\n  rw max_eq_left at h,\n  left,\n  exact h,\n  exact hcb,\n  \n  intro j,\n  cases j with d hd,\n  apply lt_of_lt_of_le d,\n  apply le_max_left,\n  apply lt_of_lt_of_le hd,\n  apply le_max_right,", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena --hide\n", "height": 18, "editorText": "sorry", "lineOffset": 23, "name": "lt_max_iff", "statement": "{a b c : \u211d} : a < max b c \u2194 a < b \u2228 a < c"}, {"type": "lean", "content": "278", "hidden": true}]}], "parents": [2]}, {"name": "279", "levels": [{"name": "", "problemIndex": 10, "objects": [{"type": "lean", "content": "280", "hidden": true}, {"type": "lean", "content": "281", "hidden": true}, {"type": "lean", "content": "282", "hidden": true}, {"type": "lean", "content": "283", "hidden": true}, {"type": "lean", "content": "284", "hidden": false}, {"type": "text", "content": "285"}, {"type": "axiom", "content": "286", "name": "subset_iff :", "sideBar": true}, {"type": "hint", "content": "287", "title": "288"}, {"type": "hint", "content": "289", "title": "290"}, {"type": "text", "content": "291"}, {"type": "lemma", "text": "292", "lean": "lemma subset.refl (A : set X) : A \u2286 A :=\n", "sideBar": true, "firstProofLineNumber": 77, "lastProofLineNumber": 79, "textBefore": "import data.set.basic -- hide\n\nimport kb_defs -- hide\n\nnamespace xena -- hide\n\nopen_locale classical -- hide\n\nvariable X : Type -- we will think of X as a set here\n\n/-\n# Chapter 1 : Sets\n\n## Level 1 : Introduction to sets.\n\nThis chapter assumes you are familiar with the following tactics:\n`rw`, `intro`, `apply`, `exact`, `cases`, `split`, `use`, `left`, `right` and `exfalso`.\n\n(TODO (kmb) : check this list is exhaustive)\n(We might need to add `ring`)\n\nIf you are not, try playing Function World and Proposition World of the Natural Number Game.\n\n## Sets in Lean\n\nIn this world, there will be an ambient \"big\" set `X` (actually `X` will be a type),\nand we will consider subsets of `X`. The type of subsets of `X` is called `set X`.\nSo if you see `A : set X` it means that `A` is a subset of `X`.\n\n## subsets (\u2286) and `subset_iff`\n\nIf `A B : set X` (i.e. `A` and `B` are subsets of `X`), then `A \u2286 B` is a\nProposition, i.e. a true/false statement. Lean knows the following fact:\n\n```\nsubset_iff : A \u2286 B \u2194 \u2200 x : X, x \u2208 A \u2192 x \u2208 B\n```\n\nLet's see if you can prove `A \u2286 A` by rewriting `subset_iff`.\n-/\n\n/- Axiom : subset_iff :\nA \u2286 B \u2194 \u2200 x : X, x \u2208 A \u2192 x \u2208 B\n-/\n\n/- Hint : Tactic tip\nThe `assumption` tactic will close a goal if it is equal to one of your\nhypotheses. It's actually longer to type than `exact hx`, but it's easier to\nuse because you don't have to bother remembering what you called `hx`.\n\n-/\n/- Hint : Stuck? Here's a hint.\nTo make progress with a goal of form `\u2200 a : X, ...`, introduce a term of type `X` by using a familiar tactic. \n\nIn this example, using\n\n`intro a,`\n\nwill introduce an arbitrary term of type `X`.\n\nNote that this is the tactic we use to assume a hypothesis (when proving an implication), or to choose an arbitrary element of some domain (when defining a function).\n\nUse the same tactic to introduce an appropriately named hypothesis for an implication, and close the goal with the `exact` tactic.\n-/\n\n/-\nIf you get stuck, you can click on the hints for more details!\n-/\n\n\n\n/- Lemma\nIf $A$ is a set of elements of type X, then $A \\subseteq A$. \n-/\nlemma subset.refl (A : set X) : A \u2286 A :=\nbegin\n", "proof": "  rw subset_iff,\n  intros x h,\n  exact h,", "proof_hint": "sorry", "textAfter": "\nend\n\n\nend xena --hide\n", "height": 3, "editorText": "sorry", "lineOffset": 76, "name": "subset.refl", "statement": "(A : set X) : A \u2286 A"}, {"type": "lean", "content": "293", "hidden": true}]}, {"name": "", "problemIndex": -1, "objects": [{"type": "lean", "content": "294", "hidden": false}]}], "parents": [1, 3]}, {"name": "295", "levels": [{"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "296", "hidden": false}, {"type": "lean", "content": "297", "hidden": true}, {"type": "lean", "content": "298", "hidden": false}, {"type": "text", "content": "299"}, {"type": "text", "content": "300"}, {"type": "lean", "content": "301", "hidden": false}, {"type": "text", "content": "302"}, {"type": "lemma", "text": "303", "lean": "lemma upper_bounds_mono (X Y : set \u211d) (h1 : X \u2286 Y) (b : \u211d) : is_upper_bound Y b \u2192 is_upper_bound X b :=\n", "sideBar": true, "firstProofLineNumber": 36, "lastProofLineNumber": 42, "textBefore": "import game.order.level09\nimport data.real.basic -- imports the real numbers \u211d\n\nnamespace xena -- hide\n\n-- World name : Sup and Inf\n\n/-\n# Chapter 3 : Sup and Inf\n\n## Level 1 : Upper bounds\n-/\n\n/-\nLet $X$ be a set of real numbers.\n\nWe say a real number $b$ is an *upper bound* for $X$ if every $x \\in X$ is at most $b$.\n-/\n\ndefinition is_upper_bound (S : set \u211d) (x : \u211d) := \u2200 s \u2208 S, s \u2264 x \n\n/-\nHere is an easy fact about upper bounds, which we shall prove below: \nIf $X \\subseteq Y$ are two sets of reals, and $b$ is an upper bound for $Y$, \nthen it's also an upper bound for $X$.\n\nYou can prove this easily in Lean using the `change` tactic. \n-/\n\n/- Lemma\nIf $X \\subseteq Y$ are two sets of reals, and $b$ is an upper bound for $Y$, \nthen it's also an upper bound for $X$.\n-/\nlemma upper_bounds_mono (X Y : set \u211d) (h1 : X \u2286 Y) (b : \u211d) : is_upper_bound Y b \u2192 is_upper_bound X b :=\nbegin\n", "proof": "  intro h,\n  intro j,\n  intro k,\n  apply h,\n  change \u2200j, j \u2208 X \u2192 j \u2208 Y at h1,\n  apply h1,\n  exact k,", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena -- hide\n\n", "height": 7, "editorText": "sorry", "lineOffset": 35, "name": "upper_bounds_mono", "statement": "(X Y : set \u211d) (h1 : X \u2286 Y) (b : \u211d) : is_upper_bound Y b \u2192 is_upper_bound X b"}, {"type": "lean", "content": "304", "hidden": true}]}, {"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "305", "hidden": false}, {"type": "lean", "content": "306", "hidden": true}, {"type": "lean", "content": "307", "hidden": false}, {"type": "text", "content": "308"}, {"type": "text", "content": "309"}, {"type": "lean", "content": "310", "hidden": false}, {"type": "lean", "content": "311", "hidden": true}, {"type": "lemma", "text": "312", "lean": "theorem nonempty_and_bounded_of_has_LUB (S : set \u211d) (H : has_lub S) : \n  (S \u2260 \u2205) \u2227 (\u2203 x, is_upper_bound S x) :=\n", "sideBar": true, "firstProofLineNumber": 38, "lastProofLineNumber": 56, "textBefore": "import game.sup_inf.level01\n\nnamespace xena -- hide\n-- World name : Sup and Inf\n\n/-\n# Chapter 3 : Sup and Inf\n\n## Level 2  \n\n-/\n\n/-\nThe completeness axiom on the reals states that any non-empty subset \n$X \\subseteq \\mathbb{R}$ that is bounded above has a least upper bound.\nHere we explore the converse statement: any set of reals that has a supremum is non-empty and \nhas an upper bound. The second part of the result is trivial, but showing that the\nset is non-empty will ask you to use techniques learned in the first world.\n-/\n\n-- definition is_upper_bound' (S : set \u211d) (x : \u211d) := x \u2208 upper_bounds S \n-- (Definition above deprecated? GT)\n\ndefinition is_lub (S : set \u211d) (x : \u211d) := is_upper_bound S x \u2227 \n\u2200 y : \u211d, is_upper_bound S y \u2192 x \u2264 y\n\ndefinition has_lub (S : set \u211d) := \u2203 x, is_lub S x \n\nlocal attribute [instance] classical.prop_decidable --hide\n\n\n/- Lemma\nAny set of reals that has a supremum is non-empty and bounded above.\n-/\ntheorem nonempty_and_bounded_of_has_LUB (S : set \u211d) (H : has_lub S) : \n  (S \u2260 \u2205) \u2227 (\u2203 x, is_upper_bound S x) :=\nbegin\n", "proof": "  cases H with b Hb,\n  split,\n  intro t,\n  have H1 : (b-1) \u2208 upper_bounds S,\n  change \u2200 x \u2208 S, x \u2264 (b-1),\n  by_contradiction hn,\n  push_neg at hn,\n  cases hn with d hd,\n  cases hd with y hy,\n  rw t at y,\n  exact y,\n  unfold is_lub at Hb,\n  have HH := Hb.2 (b-1) H1,\n  linarith,\n\n  existsi b,\n  exact Hb.1,\n\n", "proof_hint": "sorry", "textAfter": "\nend \n\nend xena -- hide\n\n\n\n\n\n\n\n/-\ncases H with b Hb,\n  -- b is LUB, Hb is proof it's LUB\n  split,\n  { -- first prove S is not empty, by contradiction as usual with empty sets\n    intro Hempty,\n    have H1 : (b-1) \u2208 upper_bounds S,\n    change \u2200 x \u2208 S, x \u2264 (b-1),\n    by_contradiction hn,\n    push_neg at hn,\n    cases hn with x h1, \n    cases h1 with h11 h12,\n    rw Hempty at h11, \n    exact h11, \n    unfold is_lub at Hb,\n    have HH := Hb.2 (b-1) H1, -- b - 1 is an upper bound\n    linarith,\n  },\n  {\n     existsi b,\n     exact Hb.1,\n  }, \n  done\n-/", "height": 19, "editorText": "sorry", "lineOffset": 37, "name": "nonempty_and_bounded_of_has_LUB", "statement": "(S : set \u211d) (H : has_lub S) : \n  (S \u2260 \u2205) \u2227 (\u2203 x, is_upper_bound S x)"}, {"type": "lean", "content": "313", "hidden": true}, {"type": "text", "content": "314"}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "315", "hidden": false}, {"type": "lean", "content": "316", "hidden": true}, {"type": "text", "content": "317"}, {"type": "text", "content": "318"}, {"type": "lean", "content": "319", "hidden": false}, {"type": "lean", "content": "320", "hidden": true}, {"type": "lemma", "text": "321", "lean": "lemma lub_of_open_set : is_lub reals_lt_59 59 := \n", "sideBar": true, "firstProofLineNumber": 41, "lastProofLineNumber": 55, "textBefore": "import game.sup_inf.level02\nimport data.real.basic\n\nnamespace xena -- hide\n\n/-\n# Chapter 3 : Sup and Inf\n\n## Level 3\n-/\n\n/- \nThis level asks you to prove what the supremum of a given open set is.\n-/\n\ndefinition reals_lt_59 := {x : \u211d | x < 59}\n\n-- begin hide\n-- The next result must be placed in the sidebar axioms.\ntheorem helper_lemma (x y : \u211d) (H : x < y) : x < (x + y) / 2 \u2227 (x + y) / 2 < y :=\nbegin\n  have two_ge_zero : (2 : \u211d) \u2265 0 := by norm_num,\n  split,\n  { apply lt_of_mul_lt_mul_right _ two_ge_zero,\n    rw [mul_two,div_mul_cancel],\n    apply add_lt_add_left H,\n    norm_num},\n  { apply lt_of_mul_lt_mul_right _ two_ge_zero,\n    rw [div_mul_cancel,mul_two],\n    apply add_lt_add_right H,\n    norm_num,\n  },\nend\n-- end hide\n\n/- Lemma\nThe LUB of...\n-/\nlemma lub_of_open_set : is_lub reals_lt_59 59 := \nbegin\n", "proof": "  split,\n  intro h,\n  intro j,\n  exact le_of_lt j,\n\n  intro h,\n  intro j,\n  apply le_of_not_gt,\n  intro k,\n  let s := (h + 59) / 2,\n  have H1 : h < s := (helper_lemma _ _ k).1,\n  have H2 : s < 59 := (helper_lemma _ _ k).2,\n  unfold is_upper_bound at j,\n  have H1' := j s H2,\n  exact not_le_of_lt H1 H1',", "proof_hint": "sorry", "textAfter": "\nend \n\nend xena -- hide\n\n\n\n\n\n\n\n/-\nsplit,\n  { intros s Hs,\n    exact le_of_lt Hs,\n  },\n  { intros y Hy,\n    apply le_of_not_gt,\n    intro H,\n    let s := (y + 59) / 2,\n    have H1 : y < s := (helper_lemma _ _ H).1,\n    have H2 : s < 59 := (helper_lemma _ _ H).2,\n--    unfold is_upper_bound at Hy,\n    have H1' := Hy s H2,\n    exact not_le_of_lt H1 H1', --of_not_gt\n  }\n-/", "height": 15, "editorText": "sorry", "lineOffset": 40, "name": "lub_of_open_set", "statement": "is_lub reals_lt_59 59"}, {"type": "lean", "content": "322", "hidden": true}, {"type": "text", "content": "323"}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "324", "hidden": false}, {"type": "lean", "content": "325", "hidden": true}, {"type": "text", "content": "326"}, {"type": "text", "content": "327"}, {"type": "lean", "content": "328", "hidden": true}, {"type": "lemma", "text": "329", "lean": "lemma lub_open (y : \u211d) : is_lub {x : \u211d | x < y} y :=\n", "sideBar": true, "firstProofLineNumber": 43, "lastProofLineNumber": 57, "textBefore": "import game.sup_inf.level03\nimport data.real.basic\n\nnamespace xena -- hide\n\n/-\n# Chapter 3 : Sup and Inf\n\n## Level 4 \n-/\n\n/-\nA generalization of the result in the previous level.\n-/\n\n-- begin hide\n-- these three helper results to go in sidebar\nlemma two_real_ne_zero : (2:\u211d) \u2260 0 :=\nbegin\n    intro, linarith,\nend\n\nlemma avg_lt_max {mn mx: \u211d} (H : mn < mx) : (mn+mx) / 2 < mx :=\nbegin\n  apply (mul_lt_mul_right (show (0:\u211d)<2, by norm_num)).1,\n  rw [div_mul_cancel _ (two_real_ne_zero)],\n  simp [H,mul_two],\nend\n\nlemma min_lt_avg {mn mx: \u211d} (H : mn < mx) : mn < (mn+mx) / 2 :=\nbegin\n  apply (mul_lt_mul_right (show (0:\u211d)<2, by norm_num)).1,\n  rw [div_mul_cancel _ (two_real_ne_zero)],\n  simp [H,mul_two],\nend\n-- end hide\n\n/- Lemma\nA more general version of the previous level...\n-/\nlemma lub_open (y : \u211d) : is_lub {x : \u211d | x < y} y :=\nbegin\n", "proof": "  split,\n  intro h,\n  intro j,\n  exact le_of_lt j,\n  intro h,\n  intro j,\n  refine le_of_not_gt _,\n  intro k,\n  let c := (h+y)/2,\n  have H2 := j c,\n  have H : c \u2208 {x : \u211d  | x < y},\n  exact avg_lt_max k,\n  have G := H2 H,\n  have P : h < c := min_lt_avg k,\n  exact not_lt.2 G P,", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena -- hide\n\n\n\n\n\n\n\n/-\nsplit,\n{ intros a ha,\n  exact le_of_lt ha, \n},\n--unfold lower_bounds,\nintro b,\nintro Hb,\nrefine le_of_not_gt _,\nintro Hnb,\nlet c:=(b+y)/2,\n--unfold upper_bounds at Hb,\nhave H2 := Hb c,\nclear Hb,\nhave H : c \u2208 {x : \u211d | x < y},\n{ exact avg_lt_max Hnb,\n},\nhave Hcleb := H2 H,\nhave Hbltc : b < c := min_lt_avg Hnb,\nexact not_lt.2 Hcleb Hbltc,\n-/\n", "height": 15, "editorText": "sorry", "lineOffset": 42, "name": "lub_open", "statement": "(y : \u211d) : is_lub {x : \u211d | x < y} y"}, {"type": "lean", "content": "330", "hidden": true}, {"type": "text", "content": "331"}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "332", "hidden": false}, {"type": "lean", "content": "333", "hidden": true}, {"type": "text", "content": "334"}, {"type": "lean", "content": "335", "hidden": true}, {"type": "lean", "content": "336", "hidden": false}, {"type": "lemma", "text": "337", "lean": "lemma sup_sum_sets (A : set \u211d) (B : set \u211d) (h1A : A.nonempty) (h1B : B.nonempty) \n  (h2A : bdd_above A) (h2B : bdd_above B) (a : \u211d) (b : \u211d) : \n  (is_lub A a) \u2227 (is_lub B b) \u2192 is_lub (mem_sum_sets A B) (a + b) :=\n", "sideBar": true, "firstProofLineNumber": 24, "lastProofLineNumber": 68, "textBefore": "import game.sup_inf.level04\n\nnamespace xena -- hide\n\n/-\n# Chapter 3 : Sup and Inf\n\n## Level 5\n\nA classical result: the supremum of an element-wise sum of sets.\n-/\n\n-- see also ds_infSum.lean for only the better-organized version -- hide\ndef mem_sum_sets (A : set \u211d) (B : set \u211d) := { x : \u211d | \u2203 y \u2208 A, \u2203 z \u2208 B, x = y + z}\n\n/- Lemma\nIf $A$ and $B$ are sets of reals, then\n$$ \\textrm{sup} (A + B) = \\textrm{sup} (A) + \\textrm{sup}(B)$$\n-/\nlemma sup_sum_sets (A : set \u211d) (B : set \u211d) (h1A : A.nonempty) (h1B : B.nonempty) \n  (h2A : bdd_above A) (h2B : bdd_above B) (a : \u211d) (b : \u211d) : \n  (is_lub A a) \u2227 (is_lub B b) \u2192 is_lub (mem_sum_sets A B) (a + b) :=\nbegin\n", "proof": "  intro h,\n  cases h with hA hB,\n  split,\n  { -- prove that (a+b) is an upper bound\n    intros x h0,\n    cases h0 with y h1, cases h1 with yA h2,\n    cases h2 with z h3, cases h3 with zB hx,\n    have H12A := hA.left, have H12B := hB.left,\n    have H13A := H12A y yA, have H13B := H12B z zB,\n    linarith,\n  },\n  -- now prove that (a+b) is the least upper bound\n  intros S hS,\n  --change \u2200 xab \u2208 (sum_of_sets A B), xab \u2264 S at hS,\n  have H1 : \u2200 y \u2208 A, \u2200 z \u2208 B, (y + z) \u2208 (mem_sum_sets A B),\n    intros y hy z hz,\n    unfold mem_sum_sets, \n    existsi y, existsi hy, existsi z, existsi hz, refl,\n  have H2 : \u2200 y \u2208 A, \u2200 z \u2208 B, (y + z) \u2264 S, \n    intros y hy z hz,\n    apply hS, exact H1 y hy z hz,\n  have H3 : \u2200 y \u2208 A, \u2200 z \u2208 B, y \u2264 S - z,\n    intros y hy z hz,\n    have H3a := H2 y hy z hz,\n    exact le_sub_right_of_add_le H3a,\n  have h21B := hB.right, have h22B := hB.left,\n  --change \u2200 z \u2208 B, z \u2264 b at h22B,\n  have H4 : \u2200 z \u2208 B, (S - z) \u2208 upper_bounds A, --!\n    intros z hz y hy,\n    exact H3 y hy z hz,\n  have H5 : \u2200 z \u2208 B, a \u2264 (S - z), \n    intros z hz,\n    have H13A := hA.right,\n    change \u2200 u \u2208 upper_bounds A, a \u2264 u at H13A,\n    have H5a := H4 z hz, \n    exact H13A (S-z) H5a,\n  have H6 : \u2200 z \u2208 B, z \u2264 S - a,\n    intros z hz,\n    have H6a := H5 z hz, exact le_sub.1 H6a,\n  --have H7 : (S - a) \u2208 upper_bounds B, exact H6,\n  have H8 : b \u2264 (S-a),\n    have H13B := hB.right,\n    change \u2200 u \u2208 upper_bounds B, b \u2264 u at H13B,\n    exact H13B (S-a) H6,  -- I had H7 instead of H6 here\n  exact add_le_of_le_sub_left H8, done", "proof_hint": "sorry", "textAfter": "\nend\n\n\n-- begin hide\n-- Kevin's term proof for second part\n-- NOTE: I altered this after is_lub changed. I don't *think* it's broken -- GT.\nlemma sup_sum_of_sets' (A : set \u211d) (B : set \u211d) (a : \u211d) (b : \u211d)\n  (hA : is_lub A a) (hB : is_lub B b) :\n  a + b \u2208 lower_bounds (upper_bounds (mem_sum_sets A B)) :=\n    \u03bb S hS, add_le_of_le_sub_left $ hB.2 (S - a) $ \u03bb z hz, le_sub.1 $ hA.2 (S - z) $ \u03bb y hy, \n    le_sub_right_of_add_le $ hS \u27e8y, hy, z, hz, rfl\u27e9\n\n-- Patrick Massot's proof for second part\nlemma sup_sum_of_sets'' (A : set \u211d) (B : set \u211d) (a : \u211d) (b : \u211d)\n  (hA : is_lub A a) (hB : is_lub B b) :\n  a + b \u2208 lower_bounds (upper_bounds (mem_sum_sets A B)) :=\nbegin\n    intros S hS,\n  have H1 : \u2200 x \u2208 A, S - x \u2208 upper_bounds B,\n  { intros x hx y hy,\n    suffices : x + y \u2264 S, by linarith, -- by rwa le_sub_iff_add_le',\n    exact hS \u27e8x, hx, y, hy, rfl\u27e9, },\n  have H2 : S - b \u2208 upper_bounds A,\n  { intros x hx,\n    suffices : b \u2264 S - x, by linarith, -- by rwa le_sub,\n    exact hB.2 (S - x) (H1 x hx) },\n  linarith [hA.2 (S - b) H2],  --exact le_sub_iff_add_le.mp (hA.2 H2),\nend\n\n--- end hide\nend xena -- hide\n", "height": 45, "editorText": "sorry", "lineOffset": 23, "name": "sup_sum_sets", "statement": "(A : set \u211d) (B : set \u211d) (h1A : A.nonempty) (h1B : B.nonempty) \n  (h2A : bdd_above A) (h2B : bdd_above B) (a : \u211d) (b : \u211d) : \n  (is_lub A a) \u2227 (is_lub B b) \u2192 is_lub (mem_sum_sets A B) (a + b)"}, {"type": "lean", "content": "338", "hidden": true}]}, {"name": "", "problemIndex": 4, "objects": [{"type": "lean", "content": "339", "hidden": false}, {"type": "lean", "content": "340", "hidden": true}, {"type": "text", "content": "341"}, {"type": "lean", "content": "342", "hidden": false}, {"type": "lemma", "text": "343", "lean": "lemma inf_sum_of_sets (A : set \u211d) (B : set \u211d) (h1A : A.nonempty) (h1B : B.nonempty) \n  (h2A : bdd_below A) (h2B : bdd_below B) (a : \u211d) (b : \u211d) : \n  (is_glb A a) \u2227 (is_glb B b) \u2192 is_glb (sum_of_sets A B) (a + b) :=\n", "sideBar": true, "firstProofLineNumber": 23, "lastProofLineNumber": 50, "textBefore": "import game.sup_inf.supSumSets\nnamespace xena -- hide\n\n/-\n# Chapter 3 : Sup and Inf\n\n## Level 6\n\nThis level, very similar to the previous, showcases the infimum.\n-/\n\ndef sum_of_sets (A : set \u211d) (B : set \u211d) := { x : \u211d | \u2203 y \u2208 A, \u2203 z \u2208 B, x = y + z}\n\n\n/- Lemma\nIf $A$ and $B$ are sets of reals, then\n$$ \\textrm{inf} (A + B) = \\textrm{inf} (A) + \\textrm{inf}(B)$$\n-/\nlemma inf_sum_of_sets (A : set \u211d) (B : set \u211d) (h1A : A.nonempty) (h1B : B.nonempty) \n  (h2A : bdd_below A) (h2B : bdd_below B) (a : \u211d) (b : \u211d) : \n  (is_glb A a) \u2227 (is_glb B b) \u2192 is_glb (sum_of_sets A B) (a + b) :=\nbegin\n", "proof": "  intro h,\n  cases h with hA hB,\n  split,\n  -- prove that (a+b) is a lower bound\n  intros x h0,\n  cases h0 with y h1,\n  cases h1 with yA h2,\n  cases h2 with z h3,\n  cases h3 with zB hx,\n  --have H11A := hA.right, have H11B := hB.right,\n  have H12A := hA.left, have H12B := hB.left,\n  have H13A := H12A yA, have H13B := H12B zB,\n  linarith,\n  -- now prove (a+b) is the greatest lower bound\n  intros L hL,  -- L is another lower bound of (A+B)\n  have H1 : \u2200 x \u2208 A, (L - x) \u2208 lower_bounds B,\n  { \n    intros x hx y hy, \n    suffices : L \u2264 x + y, by linarith,\n    exact hL \u27e8x, hx, y, hy, rfl\u27e9,\n  },\n  have H2 : L - b \u2208 lower_bounds A,\n  { \n    intros x hx, \n    suffices : L - x \u2264 b, by linarith,\n    exact hB.2 (H1 x hx),\n  },\n  linarith [hA.2 H2], done", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena -- hide\n", "height": 28, "editorText": "sorry", "lineOffset": 22, "name": "inf_sum_of_sets", "statement": "(A : set \u211d) (B : set \u211d) (h1A : A.nonempty) (h1B : B.nonempty) \n  (h2A : bdd_below A) (h2B : bdd_below B) (a : \u211d) (b : \u211d) : \n  (is_glb A a) \u2227 (is_glb B b) \u2192 is_glb (sum_of_sets A B) (a + b)"}, {"type": "lean", "content": "344", "hidden": true}]}, {"name": "", "problemIndex": 4, "objects": [{"type": "lean", "content": "345", "hidden": false}, {"type": "lean", "content": "346", "hidden": true}, {"type": "text", "content": "347"}, {"type": "lean", "content": "348", "hidden": false}, {"type": "lemma", "text": "349", "lean": "lemma inf_sum_set_const (A : set \u211d) (h1A : A.nonempty)\n  (h2A : bdd_below A) (a : \u211d) (c : \u211d): \n  (is_glb A a) \u2192 is_glb (sum_set_const A c) (c + a) :=\n", "sideBar": true, "firstProofLineNumber": 23, "lastProofLineNumber": 41, "textBefore": "import game.sup_inf.infSumSets\nnamespace xena -- hide\n\n/-\n# Chapter 3 : Sup and Inf\n\n## Level 7\n\nAnother level that showcases the infimum.\n-/\n\ndef sum_set_const (A : set \u211d) (c : \u211d) := { x : \u211d | \u2203 y \u2208 A, x = y + c}\n\n\n/- Lemma\nIf $A$ is a set of reals, then\n$$ \\textrm{inf} (c + A) = c + \\textrm{inf} (A)$$\n-/\nlemma inf_sum_set_const (A : set \u211d) (h1A : A.nonempty)\n  (h2A : bdd_below A) (a : \u211d) (c : \u211d): \n  (is_glb A a) \u2192 is_glb (sum_set_const A c) (c + a) :=\nbegin\n", "proof": "  intro h,\n  cases h with hA hB,\n  split,\n  -- prove that (c+a) is a lower bound\n  intros x h0,\n  cases h0 with y h1,\n  cases h1 with yA h2,\n  { have h2 := hA yA, linarith, },\n  -- prove that (c+a) is the GLB\n  intros L hL,\n  have h3 : L - c \u2208 lower_bounds A,\n    intros y hy,\n    set x := y + c with hx,\n    have h31 : x \u2208 sum_set_const A c,\n      unfold sum_set_const, \n      split, swap, use y, split, exact hy, exact hx,\n    have h32 := hL h31, rw hx at h32, linarith,\n  have h4 := hB h3, linarith,\n  done", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena -- hide\n", "height": 19, "editorText": "sorry", "lineOffset": 22, "name": "inf_sum_set_const", "statement": "(A : set \u211d) (h1A : A.nonempty)\n  (h2A : bdd_below A) (a : \u211d) (c : \u211d): \n  (is_glb A a) \u2192 is_glb (sum_set_const A c) (c + a)"}, {"type": "lean", "content": "350", "hidden": true}]}, {"name": "", "problemIndex": 4, "objects": [{"type": "lean", "content": "351", "hidden": false}, {"type": "lean", "content": "352", "hidden": true}, {"type": "text", "content": "353"}, {"type": "lean", "content": "354", "hidden": false}, {"type": "lemma", "text": "355", "lean": "lemma sup_const_times_set (c : \u211d) (hc: 0 < c) (A : set \u211d) (h1A : A.nonempty)\n  (h2A : bdd_above A) (a : \u211d) : \n  (is_lub A a) \u2192 is_lub (const_times_set c A) (c * a) :=\n", "sideBar": true, "firstProofLineNumber": 24, "lastProofLineNumber": 46, "textBefore": "import game.sup_inf.infSumConst\n\nnamespace xena -- hide\n\n/-\n# Chapter 3 : Sup and Inf\n\n## Level 8\n\nAgain a classical result.\n-/\n\n-- supremum of constant \u00d7 set\ndef const_times_set (c: \u211d) (A : set \u211d) := { x : \u211d | \u2203 y \u2208 A, x = c * y }\n\n/- Lemma\nIf $A$ is a set of reals and $c > 0$, then\n$$ \\textrm{sup} (cA) = c \\cdot \\textrm{sup} (A)$$\n-/\nlemma sup_const_times_set (c : \u211d) (hc: 0 < c) (A : set \u211d) (h1A : A.nonempty)\n  (h2A : bdd_above A) (a : \u211d) : \n  (is_lub A a) \u2192 is_lub (const_times_set c A) (c * a) :=\nbegin\n", "proof": "  intro h,\n  cases h with hA1 hA2,\n  split,\n  { -- prove that (c*a) is an upper bound\n    intros x h0,\n    cases h0 with y h1, cases h1 with yA h2,\n    have H13A := hA1 y yA, rw h2, \n    exact (mul_le_mul_left hc).mpr H13A,\n  },\n  -- now prove that (c*a) is the least upper bound\n  intros S hS,\n  set y1 := S / c with hys,\n  have H : y1 \u2208 upper_bounds A,\n    intros x hx,\n    have G := hA1 x hx, \n    set xc := c * x with hxc,\n    have G1 : xc \u2208 const_times_set c A, \n        use x, existsi hx, exact hxc,\n    have G2 := hS xc G1, rw hxc at G2,  \n    rw hys, exact (le_div_iff' hc).mpr G2,\n  have F := hA2 y1 H, rw hys at F, \n  have E := (mul_le_mul_left hc).mpr F,\n  exact (le_div_iff' hc).mp F, done", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena -- hide\n", "height": 23, "editorText": "sorry", "lineOffset": 23, "name": "sup_const_times_set", "statement": "(c : \u211d) (hc: 0 < c) (A : set \u211d) (h1A : A.nonempty)\n  (h2A : bdd_above A) (a : \u211d) : \n  (is_lub A a) \u2192 is_lub (const_times_set c A) (c * a)"}, {"type": "lean", "content": "356", "hidden": true}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "357", "hidden": false}, {"type": "lean", "content": "358", "hidden": true}, {"type": "text", "content": "359"}, {"type": "lean", "content": "360", "hidden": false}, {"type": "lean", "content": "361", "hidden": true}, {"type": "text", "content": "362"}, {"type": "lemma", "text": "363", "lean": "lemma mem_prod_sets_lub_proof : \n  is_lub (mem_prod_sets (set.Icc (-2:\u211d) (-1:\u211d)) (set.Icc (0:\u211d) (3:\u211d)) ) 0 := \n", "sideBar": true, "firstProofLineNumber": 31, "lastProofLineNumber": 47, "textBefore": "import ..sup_inf.supProdConst\nimport ..sets.sets_level09\n\nnamespace xena -- hide\n\n/-\n# Chapter 3 : Sup and Inf\n\n## Level 9\n\nAn intermediary result to be used in the next level.\n-/\n\n-- main result in lemma sup_mem_prod_of_sets\n-- begin hide\n--def mem_prod_sets (A : set \u211d) (B : set \u211d) := { x : \u211d | \u2203 y \u2208 A, \u2203 z \u2208 B, x = y * z}\n-- end hide\n\n\n/-\nProve that a given real number is the supremum of a particular set.\n-/\n\n/- Lemma\nGiven two sets of reals $A$ and $B$, show that given real number is the LUB\nof their elementwise product `mem_prod_sets`.\n-/\nlemma mem_prod_sets_lub_proof : \n  is_lub (mem_prod_sets (set.Icc (-2:\u211d) (-1:\u211d)) (set.Icc (0:\u211d) (3:\u211d)) ) 0 := \nbegin\n", "proof": "  split,\n  intros x h1,\n  cases h1 with a hh, cases hh with ha h2,\n  cases h2 with b h3, cases h3 with hb hx,\n  have H : a \u2264 0, \n    cases ha with hg hl,\n    linarith,\n  have G : b \u2265 0, \n    cases hb with hg hl, exact hg,\n  rw hx, exact mul_nonpos_of_nonpos_of_nonneg H G,\n  intros x hx,\n  by_contradiction hnx,\n  push_neg at hnx,\n  --TODO: kmb doesn't know what zero_in_prod is, and it's not compiling\n  have E := zero_in_prod,\n  have D := hx 0 E, linarith, done\n  --sorry", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena -- hide\n\n", "height": 17, "editorText": "sorry", "lineOffset": 30, "name": "mem_prod_sets_lub_proof", "statement": "is_lub (mem_prod_sets (set.Icc (-2:\u211d) (-1:\u211d)) (set.Icc (0:\u211d) (3:\u211d)) ) 0"}, {"type": "lean", "content": "364", "hidden": true}]}, {"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "365", "hidden": false}, {"type": "lean", "content": "366", "hidden": true}, {"type": "text", "content": "367"}, {"type": "lean", "content": "368", "hidden": false}, {"type": "lean", "content": "369", "hidden": true}, {"type": "lean", "content": "370", "hidden": false}, {"type": "text", "content": "371"}, {"type": "lemma", "text": "372", "lean": "lemma sup_mem_prod_of_sets : \u00ac ( \u2200 (A B : set \u211d) (a b : \u211d),\n  A.nonempty \u2227 B.nonempty \u2192 bdd_below A \u2227 bdd_below B \u2192\n  is_lub A a \u2227 is_lub B b \u2192 \n  is_lub (mem_prod_sets A B) (a * b) ) :=\n", "sideBar": true, "firstProofLineNumber": 34, "lastProofLineNumber": 65, "textBefore": "import .lub_prodSets\n\nnamespace xena -- hide\n\n/-\n# Chapter 3 : Sup and Inf\n\n## Level 10\n-/\n\n\n-- main result in lemma sup_mem_prod_of_sets\n-- hide\n--def mem_prod_sets (A : set \u211d) (B : set \u211d) := { x : \u211d | \u2203 y \u2208 A, \u2203 z \u2208 B, x = y * z}\n\n\n/-\nIntermediary result `zero_in_prod` proved in sets_level08.\n\nIntermediary result `mem_prod_sets_lub_proof` in previous level.\n-/\n\n\n/- Lemma\nFor two non-empty sets of reals $A$ and $B$, it is not in general true that\n$$ \\textrm{sup} (A \\cdot B) = \\textrm{sup} (A) \\cdot \\textrm{sup}(B)$$\nwhere $A \\cdot B$ is defined pointwise as above.\n-/\nlemma sup_mem_prod_of_sets : \u00ac ( \u2200 (A B : set \u211d) (a b : \u211d),\n  A.nonempty \u2227 B.nonempty \u2192 bdd_below A \u2227 bdd_below B \u2192\n  is_lub A a \u2227 is_lub B b \u2192 \n  is_lub (mem_prod_sets A B) (a * b) ) :=\nbegin\n", "proof": "  intro H,\n  -- do an example with A = [-2,-1], B = [0,3]\n  set A1 : set \u211d := set.Icc (-2:\u211d) (-1:\u211d) with hA,\n  set B1 : set \u211d := set.Icc (0:\u211d) (3:\u211d) with hB,\n  set a : \u211d := (-1:\u211d) with ha,\n  set b : \u211d := (3 : \u211d) with hb,\n  have G := H A1 B1,\n  have h1A : A1.nonempty, simp, norm_num,\n  have h1B : B1.nonempty, simp, norm_num,\n  have F := G a b (and.intro h1A h1B),\n  have h11 : ((-2:\u211d) \u2264 -1), norm_num,\n  have h21 : (0:\u211d) \u2264 (3:\u211d), norm_num,\n  have h2A : bdd_below A1, \n    -- use the definition in bounds.lean\n    have h12 := is_glb_Icc h11,\n    cases h12 with hh hhh,\n    existsi (-2:\u211d), exact hh,\n  have h2B : bdd_below B1, \n    have h22 := is_glb_Icc h21,\n    cases h22 with hh hhh,\n    existsi (0:\u211d), exact hh,\n  have E := F (and.intro h2A h2B),\n  have h1 : is_lub A1 a, \n    exact is_lub_Icc h11,\n  have h2 : is_lub B1 b, \n    exact is_lub_Icc h21,\n  have D := E (and.intro h1 h2),\n  rw ha at h1, rw hb at h2, rw ha at D, rw hb at D,\n  have E : is_lub (mem_prod_sets A1 B1) 0, \n    exact mem_prod_sets_lub_proof,\n  have E1 := is_lub.unique D E,\n  linarith, done", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena -- hide\n", "height": 32, "editorText": "sorry", "lineOffset": 33, "name": "sup_mem_prod_of_sets", "statement": "\u00ac ( \u2200 (A B : set \u211d) (a b : \u211d),\n  A.nonempty \u2227 B.nonempty \u2192 bdd_below A \u2227 bdd_below B \u2192\n  is_lub A a \u2227 is_lub B b \u2192 \n  is_lub (mem_prod_sets A B) (a * b) )"}, {"type": "lean", "content": "373", "hidden": true}]}, {"name": "", "problemIndex": 4, "objects": [{"type": "lean", "content": "374", "hidden": false}, {"type": "lean", "content": "375", "hidden": true}, {"type": "text", "content": "376"}, {"type": "lean", "content": "377", "hidden": false}, {"type": "lemma", "text": "378", "lean": "lemma not_lub_rationals : \u2200 b : \u211d, \u00ac (is_lub (embedded_rationals) b) :=\n", "sideBar": true, "firstProofLineNumber": 18, "lastProofLineNumber": 25, "textBefore": "import game.sup_inf.supProdSets\n\nnamespace xena -- hide\n\n/-\n# Chapter 3 : Sup and Inf\n\n## Level 11\n-/\n\ndef embedded_rationals : set \u211d := {x : \u211d | \u2203 y : \u211a, x = \u2191y}\n\n/- Lemma\nThe set of rational numbers does not have a supremum\n-/\nlemma not_lub_rationals : \u2200 b : \u211d, \u00ac (is_lub (embedded_rationals) b) :=\nbegin\n", "proof": "intros b Hlub,\nhave Hbub : b \u2208 upper_bounds embedded_rationals := Hlub.left,\nhave H : b < (b+1) := calc b = b+0 : (add_zero _).symm\n                         ... < b+1 : add_lt_add_left zero_lt_one _,\ncases (exists_rat_btwn H) with q Hq,\nhave Hqin : \u2191q \u2208 embedded_rationals := \u27e8q,rfl\u27e9,\nhave Hwrong2 := Hbub Hqin,\nexact not_lt.2 Hwrong2 (Hq.left),", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena -- hide\n", "height": 8, "editorText": "sorry", "lineOffset": 17, "name": "not_lub_rationals", "statement": "\u2200 b : \u211d, \u00ac (is_lub (embedded_rationals) b)"}, {"type": "lean", "content": "379", "hidden": true}]}, {"name": "", "problemIndex": 4, "objects": [{"type": "lean", "content": "380", "hidden": false}, {"type": "lean", "content": "381", "hidden": true}, {"type": "text", "content": "382"}, {"type": "lean", "content": "383", "hidden": false}, {"type": "lemma", "text": "384", "lean": "lemma nats_unbounded_iff : \n    unboundedAbove {x : \u211d | \u2203 n : \u2115, x = n \u2227 n > 0} \u2194 archimPrinciple :=\n", "sideBar": true, "firstProofLineNumber": 22, "lastProofLineNumber": 50, "textBefore": "import game.sup_inf.lub_rationals\nimport data.real.basic\n\nnamespace xena -- hide\n\n/-\n# Chapter 3 : Sup and Inf\n\n## Level 12\n-/\n\ndef unboundedAbove (A : set \u211d) := \u2200 x : \u211d, x > 0 \u2192 \u2203 a \u2208 A, x < a\n-- Might want to make this into an axiom to be placed on the left\ndef archimPrinciple := \u2200 x : \u211d, x > 0 \u2192  \u2203 n : \u2115, n > 0 \u2227 (1/n : \u211d) < x \n\n/- Lemma\nThe Archimedean principle is equivalent to the set of natural numbers being unbounded above.\n-/\nlemma nats_unbounded_iff : \n    unboundedAbove {x : \u211d | \u2203 n : \u2115, x = n \u2227 n > 0} \u2194 archimPrinciple :=\nbegin\n", "proof": "    split,\n    -- left-right implication\n    intros unb x hx,\n    set A := {x : \u211d | \u2203 n : \u2115, x = n \u2227 x > 0} with hA,\n    have h1x : (1/x) > 0, from one_div_pos_of_pos hx,\n    have h1 := unb (1/x) h1x,\n    -- rcases h1 with \u27e8nx, \u27e8n, rfl\u27e9, h2\u27e9,\n    cases h1 with nx hnx,\n    cases hnx with h1 h2,\n    cases h1 with xn h12,\n    existsi xn, rw h12.left at h2, \n    have h0 : 0 < (1:\u211d), norm_num,\n    have h3 := div_lt_div_of_pos_of_lt_of_pos h1x h2 h0,\n    split, exact h12.right,\n    simp at h3, simp, \n    exact h3,\n    -- right-left implication\n    intros arc x hx,\n    have h1x : (1/x) > 0, from one_div_pos_of_pos hx,\n    have h1 := arc (1/x) h1x,\n    cases h1 with n hn,\n    use n, split, \n    existsi n, split, refl, exact hn.left,\n    set xn : \u211d := \u2191n with hxn, \n    have h2n : 0 < xn, \n        rw hxn, \n        have hn0 : 0 < n, from hn.left, simp, assumption,\n    exact lt_of_one_div_lt_one_div h2n hn.right,\n    done", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena -- hide\n", "height": 29, "editorText": "sorry", "lineOffset": 21, "name": "nats_unbounded_iff", "statement": "unboundedAbove {x : \u211d | \u2203 n : \u2115, x = n \u2227 n > 0} \u2194 archimPrinciple"}, {"type": "lean", "content": "385", "hidden": true}]}, {"name": "", "problemIndex": 4, "objects": [{"type": "lean", "content": "386", "hidden": false}, {"type": "lean", "content": "387", "hidden": true}, {"type": "text", "content": "388"}, {"type": "lean", "content": "389", "hidden": false}, {"type": "lemma", "text": "390", "lean": "lemma not_complete_rationals : \n    \u00ac complete embedded_rationals :=\n", "sideBar": true, "firstProofLineNumber": 29, "lastProofLineNumber": 80, "textBefore": "import game.sup_inf.unbdd_iff\nimport data.real.basic\n\nnamespace xena -- hide\n\n/-\n# Chapter 3 : Sup and Inf\n\n## Level 13\n\nThis proof will be easy now.\nActually this needs quite some work due to coercions etc.\nMay need to change definitions.\n-/\n\ndef bdd (X : set \u211d) := bdd_above X \u2227 bdd_below X\ndef complete (X : set \u211d) := \n    \u2200 Y : set \u211d, Y.nonempty \u2227 Y \u2286 X \u2227 bdd Y \u2192 \u2203 s \u2208 X, is_lub Y s \u2227 \u2203 i \u2208 X, is_glb Y i\n\n\n/- Lemma\nThe rational numbers are not complete.\n\nNeed to complete the proof.\n-/\nlemma not_complete_rationals : \n    \u00ac complete embedded_rationals :=\nbegin\n", "proof": "   -- the plan here is to use the set { x : \u211a | x ^2 < 2}\n   -- this is bounded, and the sup S will satisfy neither\n   -- S ^ 2 < 2 nor S ^ 2 > 2 (due to density of rationals)\n   -- so S ^ 2 = 2, but there's not such S \u2208 \u211a\n   -- (as per sets/sqrt2NotRational.lean)\n   intro H,\n   set Y : set \u211d := { y | \u2203 x : \u211a, y = \u2191x \u2227 0 \u2264 x \u2227 x ^ 2 < (2:\u211a) } with hY,\n   -- Y is not empty\n   have h1Y : Y.nonempty, \n   {  --change \u2203 y : \u211d, y \u2208 Y,\n      use (0: \u211d), use (0 : \u211a), split, norm_cast, split,\n      linarith, rw [pow_two, zero_mul], linarith,\n   },\n   have h2Y : Y \u2286 embedded_rationals, \n   {  intros y hy, --unfold embedded_rationals,\n      cases hy with x hy1, cases hy1 with hyx hy2, --simp,\n      use x, exact hyx,\n    },\n   have h3Y : bdd Y, \n   { split, \n     -- bdd_above\n     use (2:\u211d), intros y hy, \n     cases hy with x hx1, cases hx1 with hxy hx2, cases hx2 with hx3 hx4,\n     have h1 : (2 : \u211d) < 4, linarith, \n     have h2 : (x ^ 2 : \u211d) < 4, norm_cast, linarith,\n     have h3 : 0 \u2264 (x ^ 2 : \u211d), exact pow_two_nonneg x,\n     have h4 : 0 \u2264 (4:\u211d), linarith, \n     have h5 := (real.sqrt_lt h3 h4).mpr h2,\n     have h51 : 0 \u2264 (x : \u211d), norm_cast, exact hx3,\n     have h6 := real.sqrt_sqr h51, rw h6 at h5, rw \u2190 hxy at h5,\n     have h7 : (4 : \u211d) = 2 ^ 2, norm_num, rw h7 at h5,\n     have h71 : 0 \u2264 (2 : \u211d), linarith,\n     have h8 := real.sqrt_sqr h71, rw h8 at h5, linarith,\n     -- bdd_below\n     use (0:\u211d), intros y hy,\n     cases hy with x hx1, cases hx1 with hxy hx2, cases hx2 with hx3 hx4,\n     rw hxy, norm_cast, exact hx3,\n   },\n   have G := H Y (and.intro h1Y (and.intro h2Y h3Y)), \n   cases G with S hsi, cases hsi with I hsi, cases hsi with hS hI,\n   cases lt_trichotomy (S ^ 2) 2 with hSn hS2,\n   {   -- case S ^ 2 < 2 can be sorted out: use Archimedean property / density\n       sorry, \n    },\n   cases hS2 with hS hSp, swap,\n   { -- case 2 < S^2 can also be sorted out using density of rationals\n       sorry,\n   },\n   { -- the interesting case S^2 = 2, maybe some trouble because of coercions?\n        sorry,\n   },\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena -- hide\n", "height": 52, "editorText": "sorry", "lineOffset": 28, "name": "not_complete_rationals", "statement": "\u00ac complete embedded_rationals"}, {"type": "lean", "content": "391", "hidden": true}]}, {"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "392", "hidden": false}, {"type": "lean", "content": "393", "hidden": true}, {"type": "text", "content": "394"}, {"type": "text", "content": "395"}, {"type": "lean", "content": "396", "hidden": true}, {"type": "lean", "content": "397", "hidden": false}, {"type": "text", "content": "398"}, {"type": "lean", "content": "399", "hidden": false}, {"type": "lemma", "text": "400", "lean": "theorem glb_property_reals (S: set \u211d) : \n(S.nonempty \u2227 is_bdd_below S) \u2192 has_glb S :=\n", "sideBar": true, "firstProofLineNumber": 47, "lastProofLineNumber": 91, "textBefore": "import game.sup_inf.rat_complete\n\nnamespace xena --hide \n\n/-\n# Chapter 3 : Sup and Inf\n\n## Level 14\n-/\n\n\n/- \nThe Least Upper Bound property implies\nGreatest Lower bound Property\n-/\n\n-- begin hide\n--NOTE: We have a form of the completeness axiom at Sup/Inf World\n--level 13.\n--Here I'll assume LUB property as an axiom, and prove it implies \n--GLB property. But perhaps `axiom` should be avoided. -- GT\n-- end hide\n\ndef is_bdd_above (S : set \u211d) := \u2203 x : \u211d, is_upper_bound S x    \n\ndef is_lower_bound (S : set \u211d) (x : \u211d) := \u2200 s \u2208 S, x \u2264 s\ndef is_bdd_below (S : set \u211d) := \u2203 x : \u211d, is_lower_bound S x\ndef is_glb (S : set \u211d) (x : \u211d) := is_lower_bound S x \u2227 \n\u2200 y : \u211d, is_lower_bound S y \u2192 y \u2264 x\ndef has_glb (S : set \u211d) := \u2203 x : \u211d, is_glb S x\n\n/-\nCompleteness Axiom\n-/\n\naxiom lub_property_reals (S : set \u211d) : \n(S.nonempty \u2227 is_bdd_above S) \u2192 (has_lub S)\n\n/- Lemma\nLUB property implies GLB property\n-/\n\ntheorem glb_property_reals (S: set \u211d) : \n(S.nonempty \u2227 is_bdd_below S) \u2192 has_glb S :=\n\nbegin\n", "proof": "intro hyp,\n\n--define set L of lower bounds of S\nlet L := { x : \u211d | is_lower_bound S x},  \n\n--anything in S is an upper bound of L\nhave fact1: \u2200 x \u2208 S, is_upper_bound L x,\nintros x hypx b hypb,\nexact hypb x hypx,            -- `suggest` provided this line\n\n--hyp.left is the claim that S is nonempty. use this to show\n--that L is bounded above\ncases hyp.left with y hypy, \nhave fact2: is_bdd_above L, use y, exact fact1 y hypy,\n\n-- can now show that L has supremum `a`. Note direct use of hyp.right\n-- (S is bounded below) as proof that L is nonempty\nhave fact3:= lub_property_reals L (and.intro hyp.right fact2),\ncases fact3 with a hypa,\n\n-- we now show that a is the infimum of S\n\nuse a,\nsplit,\n    -- first prove that a is a lower bound for S,\n    {\n    assume z hypz,\n    -- given z \u2208 S, we prove by contradiction that a \u2264 z,\n    by_contradiction claim,\n    push_neg at claim,\n    unfold is_lub at hypa,\n    -- hypa.right says that for any upper bound y of L, a \u2264 y\n    let for_contra := hypa.right z (fact1 z hypz), \n    -- linarith solves our goal - claim and for_contra are contradictory.\n    linarith,\n    },\n\n    -- now prove that for any lower bound x of S, x \u2264 a \n    {\n    intros x hypx,\n    have fact: x \u2208 L, exact hypx,\n    -- hypa.left says that a is an upper bound of L\n    exact hypa.left x hypx,\n    }\n", "proof_hint": "sorry", "textAfter": "\nend\n\n\nend xena -- hide\n", "height": 45, "editorText": "sorry", "lineOffset": 46, "name": "glb_property_reals", "statement": "(S: set \u211d) : \n(S.nonempty \u2227 is_bdd_below S) \u2192 has_glb S"}, {"type": "lean", "content": "401", "hidden": true}]}], "parents": [4]}, {"name": "402", "levels": [{"name": "", "problemIndex": 4, "objects": [{"type": "lean", "content": "403", "hidden": false}, {"type": "lean", "content": "404", "hidden": true}, {"type": "text", "content": "405"}, {"type": "lean", "content": "406", "hidden": false}, {"type": "lemma", "text": "407", "lean": "lemma seqlim_0_if_sum_converges (a : \u2115 \u2192 \u211d) : \n      series_converges a \u2192 is_limit a 0 :=\n", "sideBar": true, "firstProofLineNumber": 33, "lastProofLineNumber": 72, "textBefore": "import game.series.L01defs\n\nnamespace xena \n\n-- begin hide\n-- if we want to use sigma notation, use \n-- import algebra.big_operators\n-- open_locale big_operators \n-- https://leanprover-community.github.io/mathlib_docs/algebra/big_operators.html\n-- end hide\n\n/- \nIf $\\sum a_n$ converges, then $a_n \\to 0$.\n\nWe take the approach of showing that $(S_n) \u2192 M$ then $(S_{n+1}) \u2192 M$,\nand then using the fact that $a_{n+1} = S_{n+1} - S_n$.\n-/\n\ndef kth_partial_sum (a : \u2115 \u2192 \u211d) (k : \u2115) := (finset.range (k+1)).sum a\n\ndef seq_partials_over (a : \u2115 \u2192 \u211d ) : \u2115 \u2192 \u211d := (\u03bb (n : \u2115), kth_partial_sum a n )\n\ndef series_converges (a : \u2115 \u2192 \u211d) := is_convergent (seq_partials_over a)\n\n/- Lemma\nIf partial sum sequence of $a_n$ convergent, $a_n \u2192 0$.\n-/\n\nlemma seqlim_0_if_sum_converges (a : \u2115 \u2192 \u211d) : \n      series_converges a \u2192 is_limit a 0 :=\n\nbegin\n", "proof": "\nintro h,\ncases h with M Mislimit,\n\n-- shift_rule to show that shifted sequence of partial sums also tends to M\nhave fact := shift_rule (seq_partials_over a) 1 M,\nhave fact2 := iff.mp fact Mislimit,\n\n-- express `a (m+1)` using partial sums, sum_range_succ seems best way\nhave fact3 : \u2200 m : \u2115, kth_partial_sum a (m+1) \n= a (m+1) +  kth_partial_sum a (m),\nintro m, from finset.sum_range_succ a (m+1),\n\n--we really want fact4, but sum_range_succ couldn't do it directly?\nhave fact4 : \u2200 (m : \u2115), a (m + 1) = kth_partial_sum a (m+1) - kth_partial_sum a (m),\nintro n,              \nspecialize fact3 n,   -- do I need to do this to reorganise inside quantiifer?\nlinarith,       \n\n-- we can rewrite our goal in terms of `a` shifted by +1\nhave fact5 : is_limit a 0 \u2194 is_limit (\u03bb (m : \u2115), a (m+1)) 0,\n     from shift_rule a 1 0,\nrw fact5,\n\nhave fact6: \n(\u03bb (n : \u2115), a (n + 1)) = \u03bb (n: \u2115), (kth_partial_sum a (n + 1) - kth_partial_sum a n),\nexact funext fact4,  -- suggest gave me this!\n\nrw fact6,\n\nunfold seq_partials_over at Mislimit fact2, -- just for clarity\n\nhave fact7 := lim_linear \n(\u03bb (n : \u2115), kth_partial_sum a (n + 1))\n(\u03bb (n : \u2115), kth_partial_sum a n)\nM M 1 (-1) fact2 Mislimit,\n\nsimp at fact7,\nexact fact7,\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena\n", "height": 40, "editorText": "sorry", "lineOffset": 32, "name": "seqlim_0_if_sum_converges", "statement": "(a : \u2115 \u2192 \u211d) : \n      series_converges a \u2192 is_limit a 0"}, {"type": "lean", "content": "408", "hidden": false}]}, {"name": "", "problemIndex": 4, "objects": [{"type": "lean", "content": "409", "hidden": false}, {"type": "lean", "content": "410", "hidden": true}, {"type": "lean", "content": "411", "hidden": false}, {"type": "text", "content": "412"}, {"type": "lemma", "text": "413", "lean": "theorem subset_union_left (A B : set X) : A \u2286 A \u222a B :=\n", "sideBar": true, "firstProofLineNumber": 18, "lastProofLineNumber": 20, "textBefore": "import game.series.tempLevel01\nvariable X : Type --hide\n\nnamespace xena\n\n/- \nIdea 02: if $\\forall n \\in \\mathbb{N}, a_n \\ge 0$,\n$\\sum a_n$ converges iff partial sums bounded above.\n-/\n\n\n/- Lemma\nIf $A$ and $B$ are sets of any type $X$, then\n$$ A \\subseteq A\\cup B.$$ \n-/\ntheorem subset_union_left (A B : set X) : A \u2286 A \u222a B :=\nbegin\n", "proof": "    --change \u2200 (x : \u03b1), x \u2208 A \u2192 x \u2208 A \u222a B,  --they may want to do this\n    intros x hx,\n    left, exact hx, done", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena", "height": 3, "editorText": "sorry", "lineOffset": 17, "name": "subset_union_left", "statement": "(A B : set X) : A \u2286 A \u222a B"}, {"type": "lean", "content": "414", "hidden": false}]}, {"name": "", "problemIndex": 4, "objects": [{"type": "lean", "content": "415", "hidden": false}, {"type": "lean", "content": "416", "hidden": true}, {"type": "lean", "content": "417", "hidden": false}, {"type": "text", "content": "418"}, {"type": "lemma", "text": "419", "lean": "theorem comparison_test (a b : \u2115 \u2192 \u211d) \n(h1 : \u2200 (n : \u2115), 0 \u2264 a n)\n(h2 : \u2200 (n : \u2115), a n \u2264 b n) : \nseries_converges b \u2192 series_converges a :=\n", "sideBar": true, "firstProofLineNumber": 21, "lastProofLineNumber": 92, "textBefore": "import game.series.tempLevel02\nvariable X : Type --hide\n\nnamespace xena\n\n/- \nIdea 03: comparison test\n-/\n\n/- Lemma\nSuppose $0 \u2264 a_n \u2264 b_n$ for all n \u2208 \u2115. If $\u2211 b_n$ converges\nthen $\u2211 a_n$ converges and $\u2211 a_n \u2264 \u2211 b_n$.\n-/\n\ntheorem comparison_test (a b : \u2115 \u2192 \u211d) \n(h1 : \u2200 (n : \u2115), 0 \u2264 a n)\n(h2 : \u2200 (n : \u2115), a n \u2264 b n) : \nseries_converges b \u2192 series_converges a :=\n\nbegin\n", "proof": "\n--introduce hyp that series over b converges, with sum S\nintro hyp,\n\n-- we will use the following fact later\n-- our converging sequence of partials must be bounded\nhave fact := bounded_if_convergent (seq_partials_over b) hyp,\n\ncases hyp with S hypS,\n    \n    --show that partial sums over a are all positive\n    have fact1: \u2200 k : \u2115, (0 \u2264 kth_partial_sum a k),\n    unfold kth_partial_sum, -- just making finset explicit\n    intro k,\n\n        have fact2: \u2200 x \u2208 (finset.range (k + 1)), 0 \u2264 a x,\n        intros x hx,\n        specialize h1 x, exact h1,\n        \n    apply finset.sum_nonneg,\n    exact fact2,\n    \n    --show that nth partial sum over a \u2264 nth partial sum over b\n    have fact3: \u2200 k : \u2115, \n    kth_partial_sum a k \u2264 kth_partial_sum b k,\n    intro k,\n    \n        have fact4: \u2200 x \u2208 (finset.range (k + 1)), a x \u2264 b x,\n        intros x hx,\n        specialize h2 x, exact h2,\n\n    apply finset.sum_le_sum,\n    exact fact4,    \n    \n-- Although we know that our series over b converges with sum S\n-- we use the fact that the sequence of sums must be bounded \n-- by *some* T (i.e. we don't use the fact that S is the supremum)\n\ncases fact with T hypT,\n-- hypT is stated in terms of `abs`\n-- so our partial sums over b are bounded above \nhave fact5: \u2200 k : \u2115, kth_partial_sum b k \u2264 T,\nunfold seq_partials_over at hypT,\nintro K,\nhave fact6: kth_partial_sum b K \u2264 |kth_partial_sum b K|,\nexact le_abs_self (kth_partial_sum b K),\nhave :=  hypT K,\nlinarith,\n-- so our partial sums over a are bounded above \nhave fact7 : \u2200 k : \u2115, kth_partial_sum a k \u2264 T,\nintro k, specialize fact3 k, specialize fact5 k, linarith,\n-- bdd_mono_converges is the relevant theorem now.\n-- but it uses absolute values, so we will need to\n-- do a little more work using some facts proved above\nrefine bdd_mono_converges (seq_partials_over a) _ _,\nunfold seq_partials_over,\nuse T,\nintro m,\nlet fact8 := fact7 m,\nrefine max_le (fact7 m) _,\nhave fact9 := fact1 m,\nlinarith,\n\nunfold is_monotone,\nleft,\nintro n,\nunfold seq_partials_over,\nlet fact10 := finset.sum_range_succ a (n+1),\nhave fact11 := h1 (n + 1), \nunfold kth_partial_sum,\nlinarith,\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena", "height": 72, "editorText": "sorry", "lineOffset": 20, "name": "comparison_test", "statement": "(a b : \u2115 \u2192 \u211d) \n(h1 : \u2200 (n : \u2115), 0 \u2264 a n)\n(h2 : \u2200 (n : \u2115), a n \u2264 b n) : \nseries_converges b \u2192 series_converges a"}, {"type": "lean", "content": "420", "hidden": false}]}, {"name": "", "problemIndex": 3, "objects": [{"type": "lean", "content": "421", "hidden": false}, {"type": "lean", "content": "422", "hidden": true}, {"type": "text", "content": "423"}, {"type": "lemma", "text": "424", "lean": "theorem subset_union_left (A B : set X) : A \u2286 A \u222a B :=\n", "sideBar": true, "firstProofLineNumber": 15, "lastProofLineNumber": 17, "textBefore": "import game.series.L01defs\nvariable X : Type --hide\n\n/- \nIdea 04: root test\n-/\n\n\n/- Lemma\nIf $A$ and $B$ are sets of any type $X$, then\n$$ A \\subseteq A\\cup B.$$ \n-/\ntheorem subset_union_left (A B : set X) : A \u2286 A \u222a B :=\nbegin\n", "proof": "    --change \u2200 (x : \u03b1), x \u2208 A \u2192 x \u2208 A \u222a B,  --they may want to do this\n    intros x hx,\n    left, exact hx, done", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 3, "editorText": "sorry", "lineOffset": 14, "name": "subset_union_left", "statement": "(A B : set X) : A \u2286 A \u222a B"}]}, {"name": "", "problemIndex": -1, "objects": [{"type": "lean", "content": "425", "hidden": false}]}, {"name": "", "problemIndex": -1, "objects": [{"type": "lean", "content": "426", "hidden": false}]}, {"name": "", "problemIndex": -1, "objects": [{"type": "lean", "content": "427", "hidden": false}]}, {"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "428", "hidden": false}, {"type": "lean", "content": "429", "hidden": true}, {"type": "lean", "content": "430", "hidden": false}, {"type": "text", "content": "431"}, {"type": "text", "content": "432"}, {"type": "lean", "content": "433", "hidden": false}, {"type": "lean", "content": "434", "hidden": true}, {"type": "lemma", "text": "435", "lean": "theorem nonempty_and_bounded_of_has_LUB (S : set \u211d) (H : has_lub S) : \n  (S \u2260 \u2205) \u2227 (\u2203 x, is_upper_bound S x) :=\n", "sideBar": true, "firstProofLineNumber": 38, "lastProofLineNumber": 56, "textBefore": "import game.sup_inf.level01\n\nnamespace xena -- hide\n-- World name : Sup and Inf\n\n/-\n# Chapter 3 : Sup and Inf\n\n## Level 2  \n\n-/\n\n/-\nThe completeness axiom on the reals states that any non-empty subset \n$X \\subseteq \\mathbb{R}$ that is bounded above has a least upper bound.\nHere we explore the converse statement: any set of reals that has a supremum is non-empty and \nhas an upper bound. The second part of the result is trivial, but showing that the\nset is non-empty will ask you to use techniques learned in the first world.\n-/\n\n-- definition is_upper_bound' (S : set \u211d) (x : \u211d) := x \u2208 upper_bounds S \n-- (Definition above deprecated? GT)\n\ndefinition is_lub (S : set \u211d) (x : \u211d) := is_upper_bound S x \u2227 \n\u2200 y : \u211d, is_upper_bound S y \u2192 x \u2264 y\n\ndefinition has_lub (S : set \u211d) := \u2203 x, is_lub S x \n\nlocal attribute [instance] classical.prop_decidable --hide\n\n\n/- Lemma\nAny set of reals that has a supremum is non-empty and bounded above.\n-/\ntheorem nonempty_and_bounded_of_has_LUB (S : set \u211d) (H : has_lub S) : \n  (S \u2260 \u2205) \u2227 (\u2203 x, is_upper_bound S x) :=\nbegin\n", "proof": "  cases H with b Hb,\n  split,\n  intro t,\n  have H1 : (b-1) \u2208 upper_bounds S,\n  change \u2200 x \u2208 S, x \u2264 (b-1),\n  by_contradiction hn,\n  push_neg at hn,\n  cases hn with d hd,\n  cases hd with y hy,\n  rw t at y,\n  exact y,\n  unfold is_lub at Hb,\n  have HH := Hb.2 (b-1) H1,\n  linarith,\n\n  existsi b,\n  exact Hb.1,\n\n", "proof_hint": "sorry", "textAfter": "\nend \n\nend xena -- hide\n\n\n\n\n\n\n\n/-\ncases H with b Hb,\n  -- b is LUB, Hb is proof it's LUB\n  split,\n  { -- first prove S is not empty, by contradiction as usual with empty sets\n    intro Hempty,\n    have H1 : (b-1) \u2208 upper_bounds S,\n    change \u2200 x \u2208 S, x \u2264 (b-1),\n    by_contradiction hn,\n    push_neg at hn,\n    cases hn with x h1, \n    cases h1 with h11 h12,\n    rw Hempty at h11, \n    exact h11, \n    unfold is_lub at Hb,\n    have HH := Hb.2 (b-1) H1, -- b - 1 is an upper bound\n    linarith,\n  },\n  {\n     existsi b,\n     exact Hb.1,\n  }, \n  done\n-/", "height": 19, "editorText": "sorry", "lineOffset": 37, "name": "nonempty_and_bounded_of_has_LUB", "statement": "(S : set \u211d) (H : has_lub S) : \n  (S \u2260 \u2205) \u2227 (\u2203 x, is_upper_bound S x)"}, {"type": "lean", "content": "436", "hidden": true}, {"type": "text", "content": "437"}]}, {"name": "", "problemIndex": -1, "objects": [{"type": "lean", "content": "438", "hidden": false}, {"type": "lean", "content": "439", "hidden": true}, {"type": "lean", "content": "440", "hidden": false}]}, {"name": "", "problemIndex": -1, "objects": [{"type": "lean", "content": "441", "hidden": false}, {"type": "text", "content": "442"}, {"type": "lean", "content": "443", "hidden": false}]}, {"name": "", "problemIndex": -1, "objects": [{"type": "lean", "content": "444", "hidden": false}, {"type": "text", "content": "445"}]}, {"name": "", "problemIndex": -1, "objects": [{"type": "lean", "content": "446", "hidden": false}]}], "parents": [5]}, {"name": "447", "levels": [{"name": "", "problemIndex": -1, "objects": [{"type": "lean", "content": "448", "hidden": false}, {"type": "lean", "content": "449", "hidden": true}, {"type": "lean", "content": "450", "hidden": false}, {"type": "lean", "content": "451", "hidden": true}]}], "parents": [6]}], "texts": [["Real number game", "# The Real Number Game, version 1.0beta\n\n## Started by Kevin Buzzard, Dan Stanescu and Gavin Thomson\n\n## Finished by David Talone, Christian Kolker, and Jon Bannon\n\n# What is this game?\n\nWelcome to the real number game -- a game to help undergraduates learn analysis through Lean,\na formal proof verification system. Starting from the real numbers with its usual structure,\nwe develop the theory of bounds, least upper bounds and greatest lower bounds (sups and infs),\ninfinite sequences and infinite series. We develop the theory through problem-solving,\ngetting students to formalise proofs in the theory.\n\nThis game is a sequel to\n<a href=\"http://wwwf.imperial.ac.uk/~buzzard/xena/natural_number_game/\" target=\"blank\">the natural number game</a>.\nThe levels in the Real Number Game need to be solved using tactics. To learn how to use these tactics, I would\nrecommend that you first play the Natural Number Game up to at least \"Advanced Proposition world\". I will\nnot go through a careful explanation of the tactics taught by the natural number game here.\n\nBlue nodes on the graph are ones that you are ready to enter. Grey nodes you should stay away\nfrom -- try blue ones higher up the chain first. Green nodes are completed.\n\n# Thanks\n\nMany thanks to Mohammad Pedramfar, without whom this game would not exist.\n\nSeveral people contributed ideas and sometimes full proofs, most of which have found \ntheir place in the game in one way or another.\nThis aims at being a complete list eventually: Kenny Lau, Patrick Massot, Christopher Sumnicht, Aniruddh Agarwal.\n\n# Questions?\n\nYou can ask questions on the <a href=\"https://leanprover.zulipchat.com/\" target=\"blank\">Lean Zulip chat</a>,\nwhere I am often to be found. \n\nThe Real Number Game is brought to you by the Xena project, a project based at Imperial College London\nwhose aim is to get mathematics undergraduates using computer theorem provers.\nLean is a computer theorem prover being developed at Microsoft Research.\n\nProve a theorem. Write a function. <a href=\"https://twitter.com/XenaProject\" target=\"blank\">@XenaProject</a>.\n", "Sets", "import data.set.basic -- hide\n", "import kb_defs -- hide\n", "namespace xena -- hide\n", "open_locale classical -- hide\n", "variable X : Type -- we will think of X as a set here\n", "# Chapter 1 : Sets\n\n## Level 1 : Introduction to sets.\n\nThis chapter assumes you are familiar with the following tactics:\n`rw`, `intro`, `apply`, `exact`, `cases`, `split`, `use`, `left`, `right` and `exfalso`.\n\n(TODO (kmb) : check this list is exhaustive)\n(We might need to add `ring`)\n\nIf you are not, try playing Function World and Proposition World of the Natural Number Game.\n\n## Sets in Lean\n\nIn this world, there will be an ambient \"big\" set `X` (actually `X` will be a type),\nand we will consider subsets of `X`. The type of subsets of `X` is called `set X`.\nSo if you see `A : set X` it means that `A` is a subset of `X`.\n\n## subsets (\u2286) and `subset_iff`\n\nIf `A B : set X` (i.e. `A` and `B` are subsets of `X`), then `A \u2286 B` is a\nProposition, i.e. a true/false statement. Lean knows the following fact:\n\n```\nsubset_iff : A \u2286 B \u2194 \u2200 x : X, x \u2208 A \u2192 x \u2208 B\n```\n\nLet's see if you can prove `A \u2286 A` by rewriting `subset_iff`.\n", "A \u2286 B \u2194 \u2200 x : X, x \u2208 A \u2192 x \u2208 B\n", "The `assumption` tactic will close a goal if it is equal to one of your\nhypotheses. It's actually longer to type than `exact hx`, but it's easier to\nuse because you don't have to bother remembering what you called `hx`.\n\n", "Tactic tip", "To make progress with a goal of form `\u2200 a : X, ...`, introduce a term of type `X` by using a familiar tactic. \n\nIn this example, using\n\n`intro a,`\n\nwill introduce an arbitrary term of type `X`.\n\nNote that this is the tactic we use to assume a hypothesis (when proving an implication), or to choose an arbitrary element of some domain (when defining a function).\n\nUse the same tactic to introduce an appropriately named hypothesis for an implication, and close the goal with the `exact` tactic.\n", "Stuck? Here's a hint.", "If you get stuck, you can click on the hints for more details!\n", "If $A$ is a set of elements of type X, then $A \\subseteq A$. \n", "end xena --hide\n", "import game.sets.sets_level01 -- hide\n", "namespace xena -- hide\n", "open_locale classical -- hide\n", "variable X : Type -- hide\n", "# Chapter 1 : Sets\n\n## Level 2 : union (\u222a)\n", "Working with sets is very similar to working with propositions.\nLet's now prove that any set $A$ is included in its union with \nany other set $B$, or $A \u2286 A \u222a B$. To work with unions you will\nneed to know the property which classifies them:\n\n```\nmem_union_iff : x \u2208 A \u222a B \u2194 x \u2208 A \u2228 x \u2208 B\n```\n\nYou need to get yourself into a situation where the left hand side\nof `mem_union_iff` is in your goal; that way, you can `rw mem_union_iff`\nand make progress.\n", "x \u2208 A \u222a B \u2194 x \u2208 A \u2228 x \u2208 B\n", "`intros` is like `intro` but can be used to introduce more than one\nthing at once. For example if your goal is `\u22a2 \u2200 (x : X), x \u2208 A \u2192 x \u2208 A \u222a B`\nthen `intros x hx` will do the same as `intro x, intro hx`.\n", "Tactic tip : intros", "We start with a rewrite (see level 1).\nThen, after introducing your terms, you'll be able to pull off\nthe second rewrite. Finally, you'll need to prove the `left`\nside of an `or` goal.\n", "Stuck?", "If $A$ and $B$ are sets of any type $X$, then\n$$ A \\subseteq A\\cup B.$$ \n", "end xena --hide\n", "import game.sets.sets_level02 -- hide\n", "namespace xena -- hide\n", "open_locale classical -- hide\n", "variable X : Type -- hide\n", "# Chapter 1 : Sets\n\n## Level 3 : intersection (\u2229)\n", "Now prove that for any two sets $A$ and $B$, $A \u2229 B \u2286 A$.\n   \nYou will need to rewrite the following term:\n\n```\nmem_inter_iff : x \u2208 A \u2229 B \u2194 x \u2208 A \u2227 x \u2208 B \n```\n", "x \u2208 A \u2229 B \u2194 x \u2208 A \u2227 x \u2208 B\n", "You need to start the same way as in the previous levels.\nTry and get yourself into a situation where you have a\n*hypothesis* `hAB : x \u2208 A \u2229 B` and then use `rw mem_inter_iff at hAB`. \n", "Stuck?", "By convention, \u2227 binds more tightly than \u2192\n(i.e. `x \u2208 A \u2227 x \u2208 B \u2192 x \u2208 A` means `(x \u2208 A \u2227 x \u2208 B) \u2192 x \u2208 A`)\n", "A note on `x \u2208 A \u2227 x \u2208 B \u2192 x \u2208 A`", "The `cases h with hP hQ` tactic turns `h : P \u2227 Q` into `hP : P` and `hQ : Q`\n", "Reminder about `cases`", "The `tauto!` tactic solves goals in propositional logic (i.e. problems where\nthe relevant hypotheses and goal just involve `\u2227`, `\u2228`, `\u00ac` and `\u2192` and\npropositions -- for example it could easily solve this goal:\n\n```\nh : P \u2227 Q\n\u22a2 P\n```\n", "The `tauto!` tactic", "If $A$ and $B$ are sets of any type $X$, then\n$$ A \\cap B \\subseteq A.$$\n", "end xena -- hide\n", "import game.sets.sets_level03 -- hide\n", "namespace xena -- hide\n", "open_locale classical -- hide\n", "variable X : Type --hide\n", "# Chapter 1 : Sets\n\n## Level 4\n", "A = B \u2194 \u2200 x : X, x \u2208 A \u2194 x \u2208 B\n", "\nTo prove that two sets are equal, one needs to use the axiom\nof extensionality: two sets are equal if and only if they have\nthe same elements.\n\nIn Lean's maths library this axiom is called `ext_iff`.\n\n```\nlemma ext_diff : A = B \u2194 \u2200 x : X, x \u2208 A \u2194 x \u2208 B\n```\n", "\nAfter a `split` statement, one goal turns into two. A good programming style\nwould be to use `{}` brackets to work on each goal individually, like this:\n```\nbegin\n  split,\n  { insert,\n    proof of,\n    first goal\n  },\n  { insert,\n    proof of,\n    second goal\n  }\nend\n```\n\nThis way you only ever have one goal to work on, and your code becomes\neasier to read. After `split` you might want to write \n```\n{ sorry},\n{ sorry}\n```\nso that your code has no errors while you're working on it.\n", "A word on coding style", "To prove the theorem below, remember that you can use `split` to \nchange the goal into two goals, corresponding to the left-right and\nright-left implication, respectively. For the first goal, after\n`intro h,` the equality of the two sets can be manipulated\nusing `rw ext_iff`.\n", "Stuck?", "`rw` doesn't work \"under a binder\". In other words, if your goal is\n`\u22a2\t\u2200 (x : X), x \u2208 B \u2194 x \u2208 A \u222a B` then `rw mem_union_iff` won't work!\nIt's the `\u2200` which is blocking it. Either do `intro x` (and then\nthe `rw` will work), or use a more powerful rewrite tactic\ncalled `simp_rw`, which will work \n\n", "rewrite failures and the `simp_rw` tactic", "If $A$ and $B$ are sets of any type $X$, then\n$$ A \\subseteq B \\iff A \\cup B = B.$$\n", "--begin hide\n-- theorem subset_iff_union_eq' (A : set X) (B : set X) : A \u2286 B \u2194 B = A \u222a B := \n-- begin\n--   rw subset_iff,\n--   rw ext_iff,\n--   apply forall_congr,\n--   intro x,\n--   rw mem_union_iff,\n--   tauto!,\n-- end\n--end hide\n", "end xena --hide\n", "--rw subset_iff,\n  --split,\n  --{ intro h,\n    --rw ext_iff,\n     -- can't rewrite under a binder\n    --simp_rw mem_union_iff,\n    --intro x,\n    --specialize h x, -- or replace h := h x,\n    --tauto! },\n  --{ intro h,\n    --intros x hA,\n    --rw h,\n    --rw mem_union_iff,\n    --tauto!\n  --}", "import game.sets.sets_level04 -- hide\n", "namespace xena -- hide\n", "open_locale classical -- hide\n", "variable X : Type --hide\n", "# Chapter 1 : Sets\n\n## Level 5\n", "If `h : \u2200 (x : X), x \u2208 A \u2192 x \u2208 B` then `h` is a function which takes\na term `x` of type `X` as input, and also a proof that `x \u2208 A`, and outputs a\nproof that `x \u2208 B`. If you want to run this function `h` on some term `a : X`\nthen any of the following work:\n\n```\nhave h2 := h a,\nreplace h := h a,\nspecialize h a\n```\n\nThe first one preserves `h` and creates a new hypothesis `h2`. The others\nreplace `h` with `h : a \u2208 A \u2192 a \u2208 B`.\n", "If $A$ and $B$ are sets of any type $X$, then\n$$ A \\subseteq B \\iff A \\cap B = A.$$\n", "-- theorem subset_iff_intersection_eq' (A : set X) (B : set X) : A \u2286 B \u2194 A \u2229 B = A := \n-- begin\n--   rw subset_iff,\n--   rw eq_iff,\n--   apply forall_congr, -- clever trick\n--   intro x,\n--   rw mem_inter_iff, -- no longer under a binder\n--   tauto!\n-- end\n", "end xena -- hide\n", "rw subset_iff,\n  rw ext_iff,\n  split,\n  { intros h x,\n    specialize h x,\n    rw mem_inter_iff,\n    tauto!\n  },\n  { intros h x hx,\n    specialize h x,\n    rw mem_inter_iff at h,\n    tauto!,\n  }\n  -/", "import game.sets.sets_level05 -- hide\n", "import tactic -- hide\n", "namespace xena -- hide\n", "variable X : Type\n", "open_locale classical -- hide\n", "# Chapter 1 : Sets\n\n## Level 6 : `sdiff` and `neg`\n", "\nThe set-theoretic difference `A \\ B` satisfies the following property:\n\n```\nlemma mem_sdiff_iff : x \u2208 A \\ B \u2194 x \u2208 A \u2227 x \u2209 B\n```\n\nThe complement `-A` of a set `A` (often denoted $A^c$ in textbooks)\nis all the elements of `X` which are not in `A`:\n\n```\nlemma mem_neg_iff : x \u2208 -A \u2194 x \u2209 A\n```\n\nIn this lemma, you might get a shock. The `rw` tactic is aggressive\nin the Real Number Game -- if after a rewrite the goal can be\nsolved by `refl`, then Lean will close the goal automatically.\n\n", "x \u2208 A \\ B \u2194 x \u2208 A \u2227 x \u2209 B\n", "x \u2208 -A \u2194 x \u2209 A\n", "If $A$ and $B$ are sets with elements of type $X$, then\n$$(A \\setminus B) = A \\cap B^{c}.$$\n", "end xena -- hide\n", "rw ext_iff,\n  intro x,\n  rw mem_sdiff_iff,\n  rw mem_inter_iff,\n  rw mem_neg_iff,\n", "import tactic --hide\n", "import game.sets.sets_level06 -- hide\n", "variable X : Type --hide\n", "open_locale classical -- hide\n", "namespace xena -- hide\n", "# Chapter 1 : Sets\n\n## Level 7 : The empty set\n", "\nThe way to handle the empty set is the following:\n\n```\nlemma mem_empty_iff (a : X) : a \u2208 (\u2205 : set X) \u2194 false\n```\n", "a \u2208 (\u2205 : set X) \u2194 false\n", "Remember that `exfalso` changes any goal to `false`. This can be\nconvenient if your hypotheses can prove `false`.\n\nAnother approach: if `hx : false` then `cases hx` will do a case\nsplit into every proof of false -- but there are no proofs of\nfalse! So there will be no cases left to do.\n", "Stuck?", "The empty set is a subset of any set $A$. \n", "end xena\n", "rw subset_iff,\n  intros x hx,\n  exfalso,\n  rw mem_empty_iff at hx,\n  exact hx,\n\n", "import kb_real_defs --hide\n", "# Chapter 1 : Sets\n\n## Level 8\n", "This is a very basic example of working with intervals of real numbers in Lean.\nAn interval `[a, b]` that is closed at both endpoints $a$ and $b$ can be \nconstructed using `set.Icc a b`. For an open-closed interval `(a, b]`,\nthe notation\nis `set.Ioc a b`, etc. The usual closed-interval notation, using square\nbrackets, is used here as a wrapper around these definitions. We have\nthe following lemma:\n\n\n\n```\nmem_Icc_iff : x \u2208 Icc a b \u2194 a \u2264 x \u2227 x \u2264 b\n```\n", "x \u2208 Icc a b \u2194 a \u2264 x \u2227 x \u2264 b\n", "After rewriting it, the `split` tactic will isolate the two conditions for \nmembership. Each inequality goals can be solved with the `norm_num` tactic,\nwhich closes goals which are equalities or inequalities between explicit\nreal numbers.\n", "/- Pro tip : semicolons\nIf instead of a comma, you end a line with a semicolon, then\nLean will apply the next tactic to all the goals created by the\nprevious tactic, rather than just the top one.\n-/\n/- Pro tip : definitional equality\n`mem_Icc_iff` is true by definition, so you don't actually\nhave to even rewrite it.\n-/\nnotation `[` a `,` b `]`  := set.Icc a b\n", "$2 \u2208 [0,5]$\n", "rw mem_Icc_iff,\n    split;\n    norm_num,\n", "import kb_real_defs\n", "# Chapter 1 : Sets\n\n## Level 9\n", "This is a little more complicated example asking you to work with intervals of reals.\nThe result will be of help in the sup-inf world.\n", "notation `[` a `,` b `]`  := set.Icc a b\ndef mem_prod_sets (A : set \u211d) (B : set \u211d) := { x : \u211d | \u2203 y \u2208 A, \u2203 z \u2208 B, x = y * z}\n", "If $x = 0$, then `x \u2208 mem_prod_sets [(-2:\u211d),-1] [(0:\u211d), 3]`\n", "rw mem_prod_sets,\n  dsimp,\n  use -2,\n  split, \n  { rw mem_Icc_iff,\n    split; linarith\n  },\n  use 0,\n  split,\n  { rw mem_Icc_iff,\n    split; linarith\n  },\n  norm_num\n", "Order", "import game.sets.sets_level10\nimport data.real.basic\n", "namespace xena -- hide\n", "# Chapter 2 : Order\n\n## Level 1\n\nThis level aims to familiarize you with the use of the trichotomy property in \nLean, as it will come in handy in later levels.\nThis property is stated in Lean's mathlib is:\n\n`lt_trichotomy : \u2200 (a b : ?M_1), a < b \u2228 a = b \u2228 b < a`\n\nand you can just use it to finish the proof below.\n", "For any two real numbers $a$ and $b$, we have that\n$$ a < b \\lor a = b \\lor b < a$$.\n", "end xena --hide\n", "import data.real.basic\nimport game.order.level01\n", "namespace xena -- hide\n", "# Chapter 2 : Order\n\n## Level 2\n\nThis level invites you to work out a property of the absolute value.\nIn Lean the absolute value of $x$ is denoted by `abs x`. \n", "definition abs {\u03b1 : Type u} [decidable_linear_ordered_add_comm_group \u03b1] (a : \u03b1) : \u03b1 := max a (-a)\n", "The definition of the absolute value in mathlib:", "For ease of use, a notation can be wrapped around that definition as below.\n", "", "Cases, Cases, Cases!", "notation `|` x `|` := abs x\n", "For any two real numbers $a$ and $b$, we have that\n$$|ab| = |a||b|$$.\n", "end xena --hide\n", "import game.order.level02\n", "namespace xena -- hide\n", "# Chapter 2 : Order\n\n## Level 3\n\nAnother property of the absolute value.\n", "notation `|` x `|` := abs x --hide\n", "For any two real numbers $a$ and $b$, we have that\n$$|a| \u2264 c \u2194 -c \u2264 a \u2264 c$$.\n", "end xena --hide\n", "split,\n    rcases lt_trichotomy a 0 with haNeg | haZero | haPos,\n    { -- case a < 0\n        intro H, \n        have h1 : | a | = - a, exact abs_of_neg haNeg,\n        rw h1 at H, split, linarith, linarith,\n    },\n    { -- case a = 0\n        intro H, rw haZero, split, linarith, exact h,\n    },\n    { -- case 0 < a\n        intro H,\n        have h1 : |a| = a, exact abs_of_pos haPos,\n        rw h1 at H, split, linarith, exact H,\n    },\n    \n    \n    rcases lt_trichotomy a 0 with haNeg | haZero | haPos,\n    { -- case a < 0\n        intro H, \n        have h1 : | a | = - a, exact abs_of_neg haNeg,\n        rw abs_le, \n        exact H,\n    },\n    { -- case a = 0\n        intro H,\n        rw abs_le, exact H,\n    },\n    { -- case 0 < a\n        intro H,\n        rw abs_le, exact H,\n    },\n    \n\n    done\n", "import game.order.level03\n", "namespace xena -- hide\n", "# Chapter 2 : Order\n\n## Level 4\n\nThis level invites you to work out a property of the absolute value.\nIn Lean the absolute value of $x$ is denoted by `abs x`. \nFor ease of use, a notation can be used around that definition as below.\nFeel free to use the triangle inequality on the real numbers,\n\n`abs_add : \u2200 (a b : ?M_1), |a + b| \u2264 |a| + |b|`\n\ntogether with the `linarith` and `norm_num` tactics.\n", "", "a - b = a + (-b)", "notation `|` x `|` := abs x\n", "For any two real numbers $a$ and $b$, we have that\n$$| a - b| \u2264 |a| + |b|$$.\n", "end xena --hide\n", "have H : a - b = a + (-b), linarith,\n    rw H, \n    have G := abs_add a (-b),\n    have F : abs (-b) = abs b, norm_num,\n    rw F at G, exact G, done\n", "import game.order.level04\nimport game.order.H\n", "namespace xena -- hide\n", "# Chapter 2 : Order\n\n## Level 5\n\nAnother well-known property of the absolute value.\n", "notation `|` x `|` := abs x -- hide\n", "Hint: negate abs_le_if_pos_neg_le\n", "For any two real numbers $a$ and $b$, we have that\n$$| |a| - |b| | \u2264 |a - b|$$.\n", "end xena --hide\n", "import game.order.level05\nimport data.real.basic\nopen real\n", "namespace xena -- hide\n", "# Chapter 2 : Order\n\n## Level 6\n\nAn interesting result to prove.\n", "-- You will need to use lemma \n--mul_le_mul (hac : a \u2264 c) (hbd : b \u2264 d) (nn_b : 0 \u2264 b) (nn_c : 0 \u2264 c) : \n--a * b \u2264 c * d\ntheorem pow_nonneg {a : \u211d } (H : 0 \u2264 a) : \u2200 (n : \u2115), 0 \u2264 a ^ n\n| 0     := zero_le_one\n| (n+1) := mul_nonneg H (pow_nonneg _)\n", "For any two non-negative real numbers $a$ and $b$, we have that\n$$a \\le b \\iff a^2 \\le b^2 $$.\n", "end xena -- hide\n", "split,\n    intro h,\n    have h1 : a^2 \u2264 a * b, \n        have h11 : a \u2264 a, linarith,\n        have h12 := mul_le_mul h11 h ha ha,\n        have h13 : a * a = a^2, ring,\n        rw h13 at h12, exact h12,\n    have h2 : a * b \u2264 b^2, \n        have h21 : b \u2264 b, linarith,\n        have h22 := mul_le_mul h21 h ha hb,\n        rw mul_comm at h22,\n        have h23 : b * b = b^2, ring,\n        rw h23 at h22, exact h22,\n    exact le_trans h1 h2,\n    intro h,\n    have ha2 : 0 \u2264 a^2, exact pow_nonneg ha 2,\n    have hb2 : 0 \u2264 b^2, exact pow_nonneg hb 2,\n    have h1 := (sqrt_le ha2 hb2).mpr h,\n    have h2a := sqrt_sqr ha, \n    have h2b := sqrt_sqr hb,\n    rw h2a at h1, rw h2b at h1, exact h1, done\n", "import game.order.level06\nimport data.real.irrational\nopen real\n", "namespace xena -- hide\n", "# Chapter 2 : Order\n\n## Level 7\n\nProve by example that there exist pairs of real numbers\n$a$ and $b$ such that $a \\in \\mathbb{R} \\setminus \\mathbb{Q}$, \n$b \\in \\mathbb{R} \\setminus \\mathbb{Q}$,\nbut their sum $a + b$ is a rational number, $(a+b) \\in \\mathbb{Q}$.\nYou may use this result in the Lean mathlib library:\n\n`irrational_sqrt_two : irrational (sqrt 2)`\n\n", "\ntheorem irrational_neg_iff : irrational (-x) \u2194 irrational x \n\n.2 after irrational_neg_iff gives the left side of the biconditional\n\nexistsi in this case brings up 0 to the rational numbers.\n", "Not true that for any $a$, $b$, irrational numbers, the sum is \nalso an irrational number.\n", "end xena -- hide\n", "import game.order.level07\nimport data.real.irrational\nopen real\n", "namespace xena -- hide\n", "# Chapter 2 : Order\n\n## Level 8\n\nProve by example that there exist pairs of real numbers\n$a$ and $b$ such that $a \\in \\mathbb{R} \\setminus \\mathbb{Q}$, \n$b \\in \\mathbb{R} \\setminus \\mathbb{Q}$,\nbut their product $a \\cdot b$ is a rational number, $(a \\cdot b) \\in \\mathbb{Q}$.\nYou may use this result in the Lean mathlib library:\n\n`irrational_sqrt_two : irrational (sqrt 2)\n", "Not true that for any $a$, $b$, irrational numbers, the product is \nalso an irrational number.\n", "end xena -- hide\n", "import game.order.level08\nimport game.order.level02\nimport game.order.dumb\nimport game.order.lessdumb\nimport game.order.twocase\nopen real\n", "namespace xena -- hide\n", "# Chapter 2 : Order\n\n## Level 9\n\nThis level invites you to work out a property of the absolute value.\nIn Lean the absolute value of $x$ is denoted by `abs x`. \nFor ease of use, a notation can be used around that definition as below.\nFeel free to use the triangle inequality on the real numbers,\n\n`abs_add : \u2200 (a b : ?M_1), |a + b| \u2264 |a| + |b|`\n\ntogether with the `linarith` and `norm_num` tactics.\n", "notation `|` x `|` := abs x\n", "-- this to go in the side bar\nlemma eq_sqr_to_eq (a b : \u211d) (ha : 0 \u2264 a) (hb : 0 \u2264 b) : a^2 = b^2 \u2192 a = b :=\nbegin\n    intro h,\n    have h2 : sqrt (a ^ 2) = sqrt (a ^ 2),\n    refl,\n    --occurreneces.pos introduce\n    rw h at h2 {occs := occurrences.pos [2]},\n    have j := sqrt_sqr ha,\n    rw j at h2,\n    have k := sqrt_sqr hb,\n    rw k at h2,\n    exact h2,\nend\n", "For any two real numbers $a$ and $b$, we have that\n$$|a + b| = |a| + |b|$$ if and only if $ab \\ge 0$ .\n", "end xena -- hide\n", "have g : |a * b| = a * b,\n    exact abs_of_nonneg k,\n    have g2 : |a * b| = |a| * |b|,\n    exact abs_mul _ _,\n    rw g2 at g, rw mul_assoc 2 a b at H2,\n    rw \u2190 g at H2,\n    have g3 : |a| ^ 2 + 2 * ( |a| * |b| ) + |b| ^ 2 = ( |a| + |b| )^2, ring,\n    rw g3 at H2,\n    have g4 : sqrt ( |a + b| ^ 2 ) = sqrt ( |a + b| ^ 2), refl,\n    rw H2 at g4 {occs := occurrences.pos [2]},\n    have hab : 0 \u2264 |a + b|,  exact is_absolute_value.abv_nonneg abs (a+b),\n    have ha : 0 \u2264 |a|,  exact is_absolute_value.abv_nonneg abs a,\n    have hb : 0 \u2264 |b|,  exact is_absolute_value.abv_nonneg abs b,\n    have hc : 0 \u2264 |a| + |b|, linarith,\n    have G := eq_sqr_to_eq ( |a + b| ) ( |a| + |b| ) hab hc H2, exact G,\n\n\n    have g := abs_prod_eq_prod_iff_prod_nonneg a b,\n    intro k,\n    simp at k,\n    revert k,\n    rw g,\n    intro k,\n    have l := prod_nonneg_iff_eq_sign a b,\n    have p := reallydumb a b,\n    rw p,\n    have ha : 0 \u2264 |a|,  exact is_absolute_value.abv_nonneg abs a,\n    have hb : 0 \u2264 |b|,  exact is_absolute_value.abv_nonneg abs b,\n", "have H0 : (a+b)^2 = |a+b|^2, \n        have h01 := abs_mul_abs_self (a+b),\n        rw pow_two _, rw pow_two _, symmetry, exact h01,\n    have H1 : 0 \u2264 (a + b) ^ 2, exact pow_two_nonneg (a+b),\n    have H2 : (a+b) ^ 2 = a ^2 + 2 * a * b + b^2, ring,\n    have H3 : ( |a| + |b| )^2 = |a|^2 + 2*|a|*|b| + |b|^2, ring,\n    rw H0 at H2,\n    have Ha : a^2 = |a|^2, \n        have h01 := abs_mul_abs_self a,\n        rw pow_two _, rw pow_two _, symmetry, exact h01,\n    have Hb : b^2 = |b|^2, \n        have h01 := abs_mul_abs_self b,\n        rw pow_two _, rw pow_two _, symmetry, exact h01,\n    rw [Ha, Hb] at H2,\n    split,\n    intro h,\n    rw h at H2, rw H3 at H2, simp at H2, \n    rw mul_assoc at H2, rw mul_assoc at H2,\n    have g1 : ( |a| * |b| ) = (a * b), linarith,\n    have g2 : |a * b| = ( |a| * |b| ), exact abs_mul _ _, \n    rw \u2190 g2 at g1,\n    by_contradiction hn, push_neg at hn,\n    have g3 : | a * b | = - (a *b), exact abs_of_neg hn,\n    rw g1 at g3, linarith,\n    -- the right-left direction\n    intro h,\n    have g1 : |a * b| = a * b, exact abs_of_nonneg h,\n    have g2 : |a * b| = ( |a| * |b| ), exact abs_mul _ _,\n    rw g2 at g1, rw mul_assoc 2 a b at H2,\n    rw \u2190 g1 at H2,\n    have g3 : |a| ^ 2 + 2 * ( |a| * |b| ) + |b| ^ 2 = ( |a| + |b| )^2, ring,\n    rw g3 at H2,\n    have g4 : sqrt ( |a + b| ^ 2 ) = sqrt ( |a + b| ^ 2), refl,\n    rw H2 at g4 {occs := occurrences.pos [2]},\n    have hab : 0 \u2264 |a + b|,  exact is_absolute_value.abv_nonneg abs (a+b),\n    have ha : 0 \u2264 |a|,  exact is_absolute_value.abv_nonneg abs a,\n    have hb : 0 \u2264 |b|,  exact is_absolute_value.abv_nonneg abs b,\n    have hc : 0 \u2264 |a| + |b|, linarith,\n    have G := eq_sqr_to_eq ( |a + b| ) ( |a| + |b| ) hab hc H2, exact G, done\n", "Abs", "import game.max.level10\nopen_locale classical\nnoncomputable theory\nnamespace test\nvariables {a b c : \u211d}\n-- What \u211d has that a general total order hasn't got, is - .\nexample : -a \u2264 -b \u2194 b \u2264 a := by split; intros; linarith\ndef abs (x : \u211d) := max x (-x)\n-- useful for rewriting\nlemma abs_def (x : \u211d) : abs x = max x (-x) := rfl\n-- needs congr'\nlemma abs_neg (x : \u211d) : abs (-x) = abs x :=\nbegin\n  rw abs_def,\n  rw abs_def,\n  rw max_comm,\n  congr',\n  ring,\nend\n-- order level 3\n-- Powerful. Teaches them the colon. \ntheorem abs_le : abs a \u2264 b \u2194 -b \u2264 a \u2227 a \u2264 b :=\nbegin\n  rw abs_def,\n  rw max_le_iff,\n  split;\n  intro h;\n  cases h;\n  split;\n  linarith,\nend\ntheorem abs_of_nonneg (h : 0 \u2264 a) : abs a = a :=\nbegin\n  rw abs_def,\n  apply max_eq_left,\n  linarith,\nend\ntheorem abs_of_nonpos (h : a \u2264 0) : abs a = -a :=\nbegin\n  rw abs_def,\n  apply max_eq_right,\n  linarith,\nend\nvariables (a b) -- want them explicit in the next few\ntheorem abs_add : abs (a + b) \u2264 abs a + abs b :=\nbegin\n  rw abs_le,\n  cases le_total 0 a with h0a ha0,\n  { -- 0 \u2264 a\n    rw abs_of_nonneg h0a,\n    cases le_total 0 b with h0b hb0,\n    { rw abs_of_nonneg h0b,\n      split; linarith\n    },\n    { rw abs_of_nonpos hb0,\n      split; linarith\n    },\n  },\n  { -- a \u2264 0\n    rw abs_of_nonpos ha0,\n    cases le_total 0 b with h0b hb0,\n    { rw abs_of_nonneg h0b,\n      split; linarith\n    },\n    { rw abs_of_nonpos hb0,\n      split; linarith\n    },\n  },\nend\n-- order level 4\n-- convert makes this simple\ntheorem abs_sub_le_add_abs : abs (a - b) \u2264 abs a + abs b :=\nbegin\n  rw \u2190abs_neg b,\n  convert abs_add a (-b),\nend\n-- order level 5\n-- combination of ring and linarith; always try and deduce from triangle ineq\ntheorem abs_abs_sub_le_abs_sub : abs (abs a - abs b) \u2264 abs (a - b) :=\nbegin\n  rw abs_le,\n  split,\n  { have h := abs_sub_le_add_abs a (a - b),\n    ring_nf at h,\n    linarith,\n  },\n  { have h := abs_sub_le_add_abs (a - b) (-b),\n    rw abs_neg at h,\n    ring_nf at h,\n    linarith,\n  }\nend\n-- order level 2\ntheorem abs_mul (a b : \u211d) : abs (a * b) = abs a * abs b :=\nbegin\n  cases le_total 0 a with h0a ha0;\n  cases le_total 0 b with h0b hb0,\n  { -- both nonnegative\n    rw abs_of_nonneg h0a,\n    rw abs_of_nonneg h0b,\n    rw abs_of_nonneg,\n    nlinarith,\n  },\n  { -- b <= 0 <= a\n    rw abs_of_nonneg h0a,\n    rw abs_of_nonpos hb0,\n    rw abs_of_nonpos,\n    { ring},\n    nlinarith,\n  },\n  { -- a \u2264 0 \u2264 b\n    rw abs_of_nonpos ha0,\n    rw abs_of_nonneg h0b,\n    rw abs_of_nonpos,\n    { ring},\n    nlinarith,\n  },\n  { -- both nonnegative\n    rw abs_of_nonpos ha0,\n    rw abs_of_nonpos hb0,\n    rw abs_of_nonneg,\n    { ring},\n    nlinarith,\n  },  \nend\n-- order level 6 (unfinished)\nlemma le_iff_square_le (ha : 0 \u2264 a) (hb : 0 \u2264 b): a \u2264 b \u2194 a^2 \u2264 b^2 :=\nbegin\n  rw (show a^2 \u2264 b^2 \u2194 0 \u2264 b^2 - a^2, by split; intros; linarith),\n  rw (show b^2 - a^2 = (b + a) * (b - a), by ring),\n  rw (show a \u2264 b \u2194 0 \u2264 b - a, by split; intros; linarith), -- should be a lemma\n  have hab : 0 \u2264 b + a, by linarith,\n  split,\n  { intros,\n    nlinarith},\n  { intros,\n    by_cases h : b + a = 0,\n    { linarith },\n    have ha2 : 0 < b + a,\n    { by_contradiction hab,\n      push_neg at hab,\n      apply h,\n      linarith\n    },\n    sorry,\n  } \nend\nend test\n", "Max", "import tactic -- hide\n", "import data.real.basic -- imports the real numbers\n", "\n", "open_locale classical -- allow proofs by contradiction\n", "\n", "noncomputable theory -- don't fuss about the reals being noncomputable\n", "namespace xena -- hide\n", "-- Let a, b, c be real numbers\nvariables {a b c : \u211d}\n", "# Chapter ? : Max and abs\n\n## Level 1\n\nIn this chapter we develop a basic interface for the `max a b` and `abs a`\nfunction on the real numbers. Before we start, you will need to know\nthe basic API for `\u2264` and `<`, which looks like this:\n\n```\nexample : a \u2264 a := le_refl a\n\nexample : a \u2264 b \u2192 b \u2264 c \u2192 a \u2264 c := le_trans\n\nexample : a \u2264 b \u2192 b \u2264 a \u2192 a = b := le_antisymm\n\nexample : a \u2264 b \u2228 b \u2264 a := le_total a b\n\nexample : a < b \u2194 a \u2264 b \u2227 a \u2260 b := lt_iff_le_and_ne\n\nexample : a \u2264 b \u2192 b < c \u2192 a < c := lt_of_le_of_lt\n\nexample : a < b \u2192 b \u2264 c \u2192 a < c := lt_of_lt_of_le\n```\n", "", "", "", "", "", "", "", "We start with `max a b := if a \u2264 b then b else a`. It is\nuniquely characterised by the following two properties, which are hence\nall you will need to know:\n\n```\ntheorem max_eq_right : a \u2264 b \u2192 max a b = b\n\ntheorem max_eq_left : b \u2264 a \u2192 max a b = a\n```\n", "", "", "def max (a b : \u211d) := if a \u2264 b then b else a\n-- need if_pos to do this one\ntheorem max_eq_right (hab : a \u2264 b) : max a b = b :=\nbegin\n  rw max, \n  rw if_pos hab,\nend\n-- need if_neg to do this one\ntheorem max_eq_left (hba : b \u2264 a) : max a b = a :=\nbegin\n  by_cases hab : a \u2264 b,\n  rw max_eq_right hab,\n  exact le_antisymm hba hab,\n  rw max,\n  rw if_neg hab,\nend\n", "All of these theorems are in the theorem statement box on the left.\nSee if you can now prove the useful `max_choice` lemma using them.\n", "Do a case split with `cases le_total a b`. \n", "Hint", "For any two real numbers $a$ and $b$, either $\\max(a,b) = a$\nor $\\max(a,b) = b$.\n", "end xena --hide\n", "import game.max.level01 -- hide\n", "open_locale classical -- hide\n", "noncomputable theory -- hide\n", "namespace xena -- hide\n", "# Chapter ? : Max and abs\n\n## Level 2\n\n`max_comm` is the statement that `max a b = max b a`. See if you can prove it.\n", "Again, do a case split with `cases le_total a b`. \n", "Hint", "For any real numbers $a$ and $b$, we have $\\max(a,b) = \\max(b,a).$\n", "end xena --hide\n", "import game.max.level02 -- hide\n", "open_locale classical -- hide\n", "noncomputable theory -- hide\n", "namespace xena -- hide\n", "# Chapter ? : Max and abs\n\n## Level 3\n\n`le_max_left` is the statement that `a \u2264 max a b`.\n\nTechnical note: in contrast to the natural number game, the `rw` used\nin the real number game is Lean's more powerful `rw`, which automatically\ntries `refl` after a rewrite; note that `\u2264` is reflexive, so `refl` will\nclose a goal of the form `a \u2264 a`. \n", "For any real numbers $a$ and $b$, we have $a\\leq\\max(a,b).$\n", "end xena --hide\n", "import game.max.level03 -- hide\n", "open_locale classical -- hide\n", "noncomputable theory -- hide\n", "namespace xena -- hide\n", "# Chapter ? : Max and abs\n\n## Level 4\n\n`le_max_right` is the statement that `b \u2264 max a b`. There's a short\nproof using what we've already done.\n", "Why not start with `rw max_comm`?\n", "", "For any real numbers $a$ and $b$, we have $b\\leq\\max(a,b).$\n", "end xena --hide\n", "import game.max.level04 -- hide\n", "open_locale classical -- hide\n", "noncomputable theory -- hide\n", "namespace xena -- hide\n", "# Chapter ? : Max and abs\n\n## Level 5\n\n`max_le` is really useful; it says that if `a \u2264 c` and `b \u2264 c`\nthen `max a b \u2264 c`.\n\nNote that in the Lean formulation, the variables are *implicit*,\nmeaning that Lean will guess them.\n", "If $a$, $b$, $c$ are real numbers with $a\\leq c$ and $b\\leq c$,\nthen $\\max(a,b)\\leq c.$\n", "end xena --hide\n", "import game.max.level05 -- hide\n", "open_locale classical -- hide\n", "noncomputable theory -- hide\n", "namespace xena -- hide\n", "# Chapter ? : Max and abs\n\n## Level 6\n\nIn fact `max_le` can be beefed up to an iff statement.\n", "If your goal is `x \u2264 z` and you have a hypothesis `h : y \u2264 z`\nthen of course it will suffice to prove `x \u2264 y` and then you\ncan use transitivity. Instead of `have hxy : x \u2264 y,`, opening\na new goal and adding a new hypothesis to our list, you can\ndo \n\n```\napply le_trans _ h\n```\n\nor\n\n```\nrefine le_trans _ h\n```\n\nand this just reduces the goal to proving `x \u2264 y` immediately. \n\n", "Tip : using `le_trans`", "If $a$, $b$, $c$ are real numbers,\nthen ($a\\leq c$ and $b\\leq c$) iff $\\max(a,b)\\leq c.$\n", "end xena --hide\n", "  split,\n  { intro h,\n    cases h with hac hbc,\n    exact max_le hac hbc\n  },\n  { intro habc,\n    split,\n    { apply le_trans _ habc,\n      apply le_max_left},\n    { apply le_trans _ habc,\n      apply le_max_right\n    }\n  }\n", "Solution", "import game.max.level06 -- hide\n", "open_locale classical -- hide\n", "noncomputable theory -- hide\n", "namespace xena -- hide\n", "# Chapter ? : Max and abs\n\n## Level 7\n\n`max_lt` and `max_lt_iff` are equally useful. Let's knock them off\nusing the same techniques.\n", "If $a$, $b$, $c$ are real numbers with $a<c$ and $b<c$,\nthen $\\max(a,b)<c.$\n", "end xena --hide\n", "import game.max.level07 -- hide\n", "open_locale classical -- hide\n", "noncomputable theory -- hide\n", "namespace xena -- hide\n", "# Chapter ? : Max and abs\n\n## Level 8\n\nSee if you can do `max_lt_iff` without introducing\nany auxiliary hypotheses with `have`. Don't forget to\ncheck the list of theorems to see the interface for `\u2264`\nand `<`.\n", "If $a$, $b$, $c$ are real numbers,\nthen ($a<c$ and $b<c$) iff $\\max(a,b)<c.$\n", "end xena --hide\n", "import game.max.level08 -- hide\n", "open_locale classical -- hide\n", "noncomputable theory -- hide\n", "namespace xena -- hide\n", "# Chapter ? : Max\n\n## Level 9\n\nWe've done `max_le_iff`; here is `le_max_iff`. \n", "If $a$, $b$, $c$ are real numbers,\nthen $a\\leq\\max(b,c)$ iff ($a\\leq b$ or $a\\leq c$).\n", "end xena --hide\n", "import game.max.level09 -- hide\n", "open_locale classical -- hide\n", "noncomputable theory -- hide\n", "namespace xena -- hide\n", "# Chapter ? : Max\n\n## Level 10\n\nAnd finally `lt_max_iff`. \n", "If $a$, $b$, $c$ are real numbers,\nthen $a<\\max(b,c)$ iff ($a<b$ or $a<c$).\n", "end xena --hide\n", "Dense Bois", "import data.set.basic -- hide\n", "import kb_defs -- hide\n", "namespace xena -- hide\n", "open_locale classical -- hide\n", "variable X : Type -- we will think of X as a set here\n", "# Chapter 1 : Sets\n\n## Level 1 : Introduction to sets.\n\nThis chapter assumes you are familiar with the following tactics:\n`rw`, `intro`, `apply`, `exact`, `cases`, `split`, `use`, `left`, `right` and `exfalso`.\n\n(TODO (kmb) : check this list is exhaustive)\n(We might need to add `ring`)\n\nIf you are not, try playing Function World and Proposition World of the Natural Number Game.\n\n## Sets in Lean\n\nIn this world, there will be an ambient \"big\" set `X` (actually `X` will be a type),\nand we will consider subsets of `X`. The type of subsets of `X` is called `set X`.\nSo if you see `A : set X` it means that `A` is a subset of `X`.\n\n## subsets (\u2286) and `subset_iff`\n\nIf `A B : set X` (i.e. `A` and `B` are subsets of `X`), then `A \u2286 B` is a\nProposition, i.e. a true/false statement. Lean knows the following fact:\n\n```\nsubset_iff : A \u2286 B \u2194 \u2200 x : X, x \u2208 A \u2192 x \u2208 B\n```\n\nLet's see if you can prove `A \u2286 A` by rewriting `subset_iff`.\n", "A \u2286 B \u2194 \u2200 x : X, x \u2208 A \u2192 x \u2208 B\n", "The `assumption` tactic will close a goal if it is equal to one of your\nhypotheses. It's actually longer to type than `exact hx`, but it's easier to\nuse because you don't have to bother remembering what you called `hx`.\n\n", "Tactic tip", "To make progress with a goal of form `\u2200 a : X, ...`, introduce a term of type `X` by using a familiar tactic. \n\nIn this example, using\n\n`intro a,`\n\nwill introduce an arbitrary term of type `X`.\n\nNote that this is the tactic we use to assume a hypothesis (when proving an implication), or to choose an arbitrary element of some domain (when defining a function).\n\nUse the same tactic to introduce an appropriately named hypothesis for an implication, and close the goal with the `exact` tactic.\n", "Stuck? Here's a hint.", "If you get stuck, you can click on the hints for more details!\n", "If $A$ is a set of elements of type X, then $A \\subseteq A$. \n", "end xena --hide\n", "import data.real.basic\nimport tactic\nimport algebra.ring\nimport game.sets.sets_level10\nimport data.real.irrational\ndef embedded_irrationals : set \u211d := { x | \u2203 r : \u211d, x = r }\ntheorem irrat_dense_in_R : dense_in_R embedded_irrationals :=\nbegin\n  intros h j k,\n  have x : 0 < j - h,\n  simp,\n  exact k,\n  have y : 0 < (j - (real.sqrt 2)) - (h - (real.sqrt 2)),\n  linarith,\n  have p := archimedean_R ((j - real.sqrt 2) - (h - real.sqrt 2)),\n  have t := p(y),\n  cases t with n hn,\n  cases hn with v hv,\n  have v1 : 0 < (n : \u211d), simp, exact v,\n  have g : 0 < (j - real.sqrt 2 - h + real.sqrt 2 - 1 / (n : \u211d)), linarith,\n  have s : 0 < (n : \u211d) * (j - real.sqrt 2 - h + real.sqrt 2 - 1 / (n : \u211d)),\n  revert g,\n  revert v1,\n  exact mul_pos,\n  have F := has_ceiling ((n : \u211d) * (j - real.sqrt 2 - h + real.sqrt 2 - 1 / (n : \u211d))),\n  cases F with m hm,\n  cases hm with z hz,\n  have J : j - real.sqrt 2 - h + real.sqrt 2 - 1 / (n : \u211d) = (j - real.sqrt 2) + (-h + real.sqrt 2)\n   + (-1 / (n : \u211d)),\n  ring,\n  rw J at s,\n  have P : (j - real.sqrt 2 + (-h + real.sqrt 2)) = ((j - real.sqrt 2) + (-h + real.sqrt 2)),\n  linarith,\n  rw P at s,\n  rw add_assoc at s,\n  rw left_distrib at s,\n  rw left_distrib at s,\n  field_simp at s,\n  have L : - (n : \u211d) / (n : \u211d) = -1,\n  ring,\n  rw inv_mul_cancel,\n  linarith,\n  rw L at s,\n  rw left_distrib at s,\n  have I : j - real.sqrt 2 = j + (- real.sqrt 2),\n  linarith,\n  rw I at s,\n  rw left_distrib at s,\n  have D := has_ceiling (\u2191n * h - \u2191n * real.sqrt 2),\n  cases D with r hr,\n  cases hr with b hb,\n  have U : \u2191r \u2264 \u2191n * h - \u2191n * real.sqrt 2 + 1,\n  linarith,\n  use ((\u2191r / \u2191n) + real.sqrt 2 : \u211d),\n  split,\n  unfold embedded_irrationals,\n  use ((\u2191r / \u2191n) + real.sqrt 2 : \u211d),\n  unfold set.Ioo,\n  split,\n  have duh2 : \u2191n * (h - real.sqrt 2) = \u2191n * h - \u2191n * real.sqrt 2, linarith,\n  have Y : (\u2191n * (h - real.sqrt 2)) * (1 / \u2191n) < \u2191r * (1 / \u2191n),\n  rw duh2,\n  finish,\n  rw mul_assoc at Y,\n  rw mul_comm \u2191n _ at Y,\n  rw mul_assoc at Y,\n  rw inv_prod_self at Y,\n  swap,\n  exact v,\n  rw mul_one at Y,\n  field_simp at Y,\n  linarith,\n  have HP : \u2191r < (j - real.sqrt 2) * \u2191n,\n  linarith,\n  have P : \u2191r * (1 / \u2191n) < ((j - real.sqrt 2) * \u2191n) * (1 / \u2191n),\n  finish,\n  rw mul_assoc at P,\n  rw mul_comm \u2191n _ at P,\n  rw inv_prod_self at P,\n  swap,\n  exact v,\n  rw mul_one at P,\n  field_simp at P,\n  linarith,\nend", "Sup and Inf", "import game.order.level09\nimport data.real.basic -- imports the real numbers \u211d\n", "namespace xena -- hide\n", "-- World name : Sup and Inf\n", "# Chapter 3 : Sup and Inf\n\n## Level 1 : Upper bounds\n", "Let $X$ be a set of real numbers.\n\nWe say a real number $b$ is an *upper bound* for $X$ if every $x \\in X$ is at most $b$.\n", "definition is_upper_bound (S : set \u211d) (x : \u211d) := \u2200 s \u2208 S, s \u2264 x \n", "Here is an easy fact about upper bounds, which we shall prove below: \nIf $X \\subseteq Y$ are two sets of reals, and $b$ is an upper bound for $Y$, \nthen it's also an upper bound for $X$.\n\nYou can prove this easily in Lean using the `change` tactic. \n", "If $X \\subseteq Y$ are two sets of reals, and $b$ is an upper bound for $Y$, \nthen it's also an upper bound for $X$.\n", "end xena -- hide\n", "import game.sup_inf.level01\n", "namespace xena -- hide\n", "-- World name : Sup and Inf\n", "# Chapter 3 : Sup and Inf\n\n## Level 2  \n\n", "The completeness axiom on the reals states that any non-empty subset \n$X \\subseteq \\mathbb{R}$ that is bounded above has a least upper bound.\nHere we explore the converse statement: any set of reals that has a supremum is non-empty and \nhas an upper bound. The second part of the result is trivial, but showing that the\nset is non-empty will ask you to use techniques learned in the first world.\n", "-- definition is_upper_bound' (S : set \u211d) (x : \u211d) := x \u2208 upper_bounds S \n-- (Definition above deprecated? GT)\ndefinition is_lub (S : set \u211d) (x : \u211d) := is_upper_bound S x \u2227 \n\u2200 y : \u211d, is_upper_bound S y \u2192 x \u2264 y\ndefinition has_lub (S : set \u211d) := \u2203 x, is_lub S x \n", "local attribute [instance] classical.prop_decidable --hide\n", "Any set of reals that has a supremum is non-empty and bounded above.\n", "end xena -- hide\n", "cases H with b Hb,\n  -- b is LUB, Hb is proof it's LUB\n  split,\n  { -- first prove S is not empty, by contradiction as usual with empty sets\n    intro Hempty,\n    have H1 : (b-1) \u2208 upper_bounds S,\n    change \u2200 x \u2208 S, x \u2264 (b-1),\n    by_contradiction hn,\n    push_neg at hn,\n    cases hn with x h1, \n    cases h1 with h11 h12,\n    rw Hempty at h11, \n    exact h11, \n    unfold is_lub at Hb,\n    have HH := Hb.2 (b-1) H1, -- b - 1 is an upper bound\n    linarith,\n  },\n  {\n     existsi b,\n     exact Hb.1,\n  }, \n  done\n", "import game.sup_inf.level02\nimport data.real.basic\n", "namespace xena -- hide\n", "# Chapter 3 : Sup and Inf\n\n## Level 3\n", "This level asks you to prove what the supremum of a given open set is.\n", "definition reals_lt_59 := {x : \u211d | x < 59}\n", "-- The next result must be placed in the sidebar axioms.\ntheorem helper_lemma (x y : \u211d) (H : x < y) : x < (x + y) / 2 \u2227 (x + y) / 2 < y :=\nbegin\n  have two_ge_zero : (2 : \u211d) \u2265 0 := by norm_num,\n  split,\n  { apply lt_of_mul_lt_mul_right _ two_ge_zero,\n    rw [mul_two,div_mul_cancel],\n    apply add_lt_add_left H,\n    norm_num},\n  { apply lt_of_mul_lt_mul_right _ two_ge_zero,\n    rw [div_mul_cancel,mul_two],\n    apply add_lt_add_right H,\n    norm_num,\n  },\nend\n", "The LUB of...\n", "end xena -- hide\n", "split,\n  { intros s Hs,\n    exact le_of_lt Hs,\n  },\n  { intros y Hy,\n    apply le_of_not_gt,\n    intro H,\n    let s := (y + 59) / 2,\n    have H1 : y < s := (helper_lemma _ _ H).1,\n    have H2 : s < 59 := (helper_lemma _ _ H).2,\n--    unfold is_upper_bound at Hy,\n    have H1' := Hy s H2,\n    exact not_le_of_lt H1 H1', --of_not_gt\n  }\n", "import game.sup_inf.level03\nimport data.real.basic\n", "namespace xena -- hide\n", "# Chapter 3 : Sup and Inf\n\n## Level 4 \n", "A generalization of the result in the previous level.\n", "-- these three helper results to go in sidebar\nlemma two_real_ne_zero : (2:\u211d) \u2260 0 :=\nbegin\n    intro, linarith,\nend\nlemma avg_lt_max {mn mx: \u211d} (H : mn < mx) : (mn+mx) / 2 < mx :=\nbegin\n  apply (mul_lt_mul_right (show (0:\u211d)<2, by norm_num)).1,\n  rw [div_mul_cancel _ (two_real_ne_zero)],\n  simp [H,mul_two],\nend\nlemma min_lt_avg {mn mx: \u211d} (H : mn < mx) : mn < (mn+mx) / 2 :=\nbegin\n  apply (mul_lt_mul_right (show (0:\u211d)<2, by norm_num)).1,\n  rw [div_mul_cancel _ (two_real_ne_zero)],\n  simp [H,mul_two],\nend\n", "A more general version of the previous level...\n", "end xena -- hide\n", "split,\n{ intros a ha,\n  exact le_of_lt ha, \n},\n--unfold lower_bounds,\nintro b,\nintro Hb,\nrefine le_of_not_gt _,\nintro Hnb,\nlet c:=(b+y)/2,\n--unfold upper_bounds at Hb,\nhave H2 := Hb c,\nclear Hb,\nhave H : c \u2208 {x : \u211d | x < y},\n{ exact avg_lt_max Hnb,\n},\nhave Hcleb := H2 H,\nhave Hbltc : b < c := min_lt_avg Hnb,\nexact not_lt.2 Hcleb Hbltc,\n", "import game.sup_inf.level04\n", "namespace xena -- hide\n", "# Chapter 3 : Sup and Inf\n\n## Level 5\n\nA classical result: the supremum of an element-wise sum of sets.\n", "-- see also ds_infSum.lean for only the better-organized version -- hide\n", "def mem_sum_sets (A : set \u211d) (B : set \u211d) := { x : \u211d | \u2203 y \u2208 A, \u2203 z \u2208 B, x = y + z}\n", "If $A$ and $B$ are sets of reals, then\n$$ \\textrm{sup} (A + B) = \\textrm{sup} (A) + \\textrm{sup}(B)$$\n", "-- Kevin's term proof for second part\n-- NOTE: I altered this after is_lub changed. I don't *think* it's broken -- GT.\nlemma sup_sum_of_sets' (A : set \u211d) (B : set \u211d) (a : \u211d) (b : \u211d)\n  (hA : is_lub A a) (hB : is_lub B b) :\n  a + b \u2208 lower_bounds (upper_bounds (mem_sum_sets A B)) :=\n    \u03bb S hS, add_le_of_le_sub_left $ hB.2 (S - a) $ \u03bb z hz, le_sub.1 $ hA.2 (S - z) $ \u03bb y hy, \n    le_sub_right_of_add_le $ hS \u27e8y, hy, z, hz, rfl\u27e9\n-- Patrick Massot's proof for second part\nlemma sup_sum_of_sets'' (A : set \u211d) (B : set \u211d) (a : \u211d) (b : \u211d)\n  (hA : is_lub A a) (hB : is_lub B b) :\n  a + b \u2208 lower_bounds (upper_bounds (mem_sum_sets A B)) :=\nbegin\n    intros S hS,\n  have H1 : \u2200 x \u2208 A, S - x \u2208 upper_bounds B,\n  { intros x hx y hy,\n    suffices : x + y \u2264 S, by linarith, -- by rwa le_sub_iff_add_le',\n    exact hS \u27e8x, hx, y, hy, rfl\u27e9, },\n  have H2 : S - b \u2208 upper_bounds A,\n  { intros x hx,\n    suffices : b \u2264 S - x, by linarith, -- by rwa le_sub,\n    exact hB.2 (S - x) (H1 x hx) },\n  linarith [hA.2 (S - b) H2],  --exact le_sub_iff_add_le.mp (hA.2 H2),\nend\n--- end hide\nend xena -- hide\n", "import game.sup_inf.supSumSets\n", "namespace xena -- hide\n", "# Chapter 3 : Sup and Inf\n\n## Level 6\n\nThis level, very similar to the previous, showcases the infimum.\n", "def sum_of_sets (A : set \u211d) (B : set \u211d) := { x : \u211d | \u2203 y \u2208 A, \u2203 z \u2208 B, x = y + z}\n", "If $A$ and $B$ are sets of reals, then\n$$ \\textrm{inf} (A + B) = \\textrm{inf} (A) + \\textrm{inf}(B)$$\n", "end xena -- hide\n", "import game.sup_inf.infSumSets\n", "namespace xena -- hide\n", "# Chapter 3 : Sup and Inf\n\n## Level 7\n\nAnother level that showcases the infimum.\n", "def sum_set_const (A : set \u211d) (c : \u211d) := { x : \u211d | \u2203 y \u2208 A, x = y + c}\n", "If $A$ is a set of reals, then\n$$ \\textrm{inf} (c + A) = c + \\textrm{inf} (A)$$\n", "end xena -- hide\n", "import game.sup_inf.infSumConst\n", "namespace xena -- hide\n", "# Chapter 3 : Sup and Inf\n\n## Level 8\n\nAgain a classical result.\n", "-- supremum of constant \u00d7 set\ndef const_times_set (c: \u211d) (A : set \u211d) := { x : \u211d | \u2203 y \u2208 A, x = c * y }\n", "If $A$ is a set of reals and $c > 0$, then\n$$ \\textrm{sup} (cA) = c \\cdot \\textrm{sup} (A)$$\n", "end xena -- hide\n", "import ..sup_inf.supProdConst\nimport ..sets.sets_level09\n", "namespace xena -- hide\n", "# Chapter 3 : Sup and Inf\n\n## Level 9\n\nAn intermediary result to be used in the next level.\n", "-- main result in lemma sup_mem_prod_of_sets\n", "--def mem_prod_sets (A : set \u211d) (B : set \u211d) := { x : \u211d | \u2203 y \u2208 A, \u2203 z \u2208 B, x = y * z}\n", "Prove that a given real number is the supremum of a particular set.\n", "Given two sets of reals $A$ and $B$, show that given real number is the LUB\nof their elementwise product `mem_prod_sets`.\n", "end xena -- hide\n", "import .lub_prodSets\n", "namespace xena -- hide\n", "# Chapter 3 : Sup and Inf\n\n## Level 10\n", "-- main result in lemma sup_mem_prod_of_sets\n", "-- hide\n", "--def mem_prod_sets (A : set \u211d) (B : set \u211d) := { x : \u211d | \u2203 y \u2208 A, \u2203 z \u2208 B, x = y * z}\n", "Intermediary result `zero_in_prod` proved in sets_level08.\n\nIntermediary result `mem_prod_sets_lub_proof` in previous level.\n", "For two non-empty sets of reals $A$ and $B$, it is not in general true that\n$$ \\textrm{sup} (A \\cdot B) = \\textrm{sup} (A) \\cdot \\textrm{sup}(B)$$\nwhere $A \\cdot B$ is defined pointwise as above.\n", "end xena -- hide\n", "import game.sup_inf.supProdSets\n", "namespace xena -- hide\n", "# Chapter 3 : Sup and Inf\n\n## Level 11\n", "def embedded_rationals : set \u211d := {x : \u211d | \u2203 y : \u211a, x = \u2191y}\n", "The set of rational numbers does not have a supremum\n", "end xena -- hide\n", "import game.sup_inf.lub_rationals\nimport data.real.basic\n", "namespace xena -- hide\n", "# Chapter 3 : Sup and Inf\n\n## Level 12\n", "def unboundedAbove (A : set \u211d) := \u2200 x : \u211d, x > 0 \u2192 \u2203 a \u2208 A, x < a\n-- Might want to make this into an axiom to be placed on the left\ndef archimPrinciple := \u2200 x : \u211d, x > 0 \u2192  \u2203 n : \u2115, n > 0 \u2227 (1/n : \u211d) < x \n", "The Archimedean principle is equivalent to the set of natural numbers being unbounded above.\n", "end xena -- hide\n", "import game.sup_inf.unbdd_iff\nimport data.real.basic\n", "namespace xena -- hide\n", "# Chapter 3 : Sup and Inf\n\n## Level 13\n\nThis proof will be easy now.\nActually this needs quite some work due to coercions etc.\nMay need to change definitions.\n", "def bdd (X : set \u211d) := bdd_above X \u2227 bdd_below X\ndef complete (X : set \u211d) := \n    \u2200 Y : set \u211d, Y.nonempty \u2227 Y \u2286 X \u2227 bdd Y \u2192 \u2203 s \u2208 X, is_lub Y s \u2227 \u2203 i \u2208 X, is_glb Y i\n", "The rational numbers are not complete.\nNeed to complete the proof.\n", "end xena -- hide\n", "import game.sup_inf.rat_complete\n", "namespace xena --hide \n", "# Chapter 3 : Sup and Inf\n\n## Level 14\n", "The Least Upper Bound property implies\nGreatest Lower bound Property\n", "--NOTE: We have a form of the completeness axiom at Sup/Inf World\n--level 13.\n--Here I'll assume LUB property as an axiom, and prove it implies \n--GLB property. But perhaps `axiom` should be avoided. -- GT\n", "def is_bdd_above (S : set \u211d) := \u2203 x : \u211d, is_upper_bound S x    \ndef is_lower_bound (S : set \u211d) (x : \u211d) := \u2200 s \u2208 S, x \u2264 s\ndef is_bdd_below (S : set \u211d) := \u2203 x : \u211d, is_lower_bound S x\ndef is_glb (S : set \u211d) (x : \u211d) := is_lower_bound S x \u2227 \n\u2200 y : \u211d, is_lower_bound S y \u2192 y \u2264 x\ndef has_glb (S : set \u211d) := \u2203 x : \u211d, is_glb S x\n", "Completeness Axiom\n", "axiom lub_property_reals (S : set \u211d) : \n(S.nonempty \u2227 is_bdd_above S) \u2192 (has_lub S)\n", "LUB property implies GLB property\n", "end xena -- hide\n", "Completeness", "import game.series.L01defs\nnamespace xena \n", "-- if we want to use sigma notation, use \n-- import algebra.big_operators\n-- open_locale big_operators \n-- https://leanprover-community.github.io/mathlib_docs/algebra/big_operators.html\n", "If $\\sum a_n$ converges, then $a_n \\to 0$.\n\nWe take the approach of showing that $(S_n) \u2192 M$ then $(S_{n+1}) \u2192 M$,\nand then using the fact that $a_{n+1} = S_{n+1} - S_n$.\n", "def kth_partial_sum (a : \u2115 \u2192 \u211d) (k : \u2115) := (finset.range (k+1)).sum a\ndef seq_partials_over (a : \u2115 \u2192 \u211d ) : \u2115 \u2192 \u211d := (\u03bb (n : \u2115), kth_partial_sum a n )\ndef series_converges (a : \u2115 \u2192 \u211d) := is_convergent (seq_partials_over a)\n", "If partial sum sequence of $a_n$ convergent, $a_n \u2192 0$.\n", "end xena\n", "import game.series.tempLevel01\n", "variable X : Type --hide\n", "namespace xena\n", "Idea 02: if $\\forall n \\in \\mathbb{N}, a_n \\ge 0$,\n$\\sum a_n$ converges iff partial sums bounded above.\n", "If $A$ and $B$ are sets of any type $X$, then\n$$ A \\subseteq A\\cup B.$$ \n", "end xena", "import game.series.tempLevel02\n", "variable X : Type --hide\n", "namespace xena\n", "Idea 03: comparison test\n", "Suppose $0 \u2264 a_n \u2264 b_n$ for all n \u2208 \u2115. If $\u2211 b_n$ converges\nthen $\u2211 a_n$ converges and $\u2211 a_n \u2264 \u2211 b_n$.\n", "end xena", "import game.series.L01defs\n", "variable X : Type --hide\n", "Idea 04: root test\n", "If $A$ and $B$ are sets of any type $X$, then\n$$ A \\subseteq A\\cup B.$$ \n", "import data.real.basic\nimport tactic.suggest\nnoncomputable theory\nopen_locale classical\ndef up_bounds (A : set \u211d) := { x : \u211d | \u2200 a \u2208 A, a \u2264 x}\ndef is_maximum (a : \u211d) (A : set \u211d) := a \u2208 A \u2227 a \u2208 up_bounds A\ninfix ` is_a_max_of `:55 := is_maximum\ndef low_bounds (A : set \u211d) := { x : \u211d | \u2200 a \u2208 A, x \u2264 a}\ndef is_inf (x : \u211d) (A : set \u211d) := x is_a_max_of (low_bounds A)\ninfix ` is_an_inf_of `:55 := is_inf\nlemma unique_max (A : set \u211d) (x y : \u211d) (hx : x is_a_max_of A) (hy : y is_a_max_of A) : x = y :=\nbegin\n  -- We first break our assumptions in their two constituent pieces.\n  -- We are free to choose the name following `with`\n  cases hx with x_in x_up,\n  cases hy with y_in y_up,\n  -- Assumption `x_up` means x isn't less than elements of A, let's apply this to y\n  specialize x_up y,\n  -- Assumption `x_up` now needs the information that `y` is indeed in `A`.\n  specialize x_up y_in,\n  -- Let's do this quicker with roles swapped\n  specialize y_up x x_in,\n  -- We explained to Lean the idea of this proof.\n  -- Now we know `x \u2264 y` and `y \u2264 x`, and Lean shouldn't need more help.\n  -- `linarith` proves equalities and inequalities that follow linearly from\n  -- the assumption we have.\n  linarith,\nend\n", "import game.Completeness.level01\nimport tactic\ndef upper_bound (A : set \u211d) (x : \u211d) := \u2200 a \u2208 A, a \u2264 x\ndef is_sup (A : set \u211d) (x : \u211d) := upper_bound A x \u2227 \u2200 y, upper_bound A y \u2192 x \u2264 y\nexample {A : set \u211d} {x : \u211d} (hx : is_sup A x) :\n\u2200 y, y < x \u2192 \u2203 a \u2208 A, y < a :=\nbegin\n  intro h,\n  contrapose!,\n  exact hx.right h,\nend\n", "import data.real.basic\nimport tactic.suggest\nimport game.Completeness.level01\nnoncomputable theory\nopen_locale classical\nlemma inf_lt {A : set \u211d} {x : \u211d} (hx : x is_an_inf_of A) :\n  \u2200 y, x < y \u2192 \u2203 a \u2208 A, a < y :=\nbegin\n  -- Let `y` be any real number.\n  intro y,\n  -- Let's prove the contrapositive\n  contrapose,\n  -- The symbol `\u00ac` means negation. Let's ask Lean to rewrite the goal without negation,\n  -- pushing negation through quantifiers and inequalities\n  push_neg,\n  -- Let's assume the premise, calling the assumption `h`\n  intro h,\n  -- `h` is exactly saying `y` is a lower bound of `A` so the second part of\n  -- the infimum assumption `hx` applied to `y` and `h` is exactly what we want.\n  exact hx.2 y h\nend\n", "import game.sup_inf.level01\n", "namespace xena -- hide\n", "-- World name : Sup and Inf\n", "# Chapter 3 : Sup and Inf\n\n## Level 2  \n\n", "The completeness axiom on the reals states that any non-empty subset \n$X \\subseteq \\mathbb{R}$ that is bounded above has a least upper bound.\nHere we explore the converse statement: any set of reals that has a supremum is non-empty and \nhas an upper bound. The second part of the result is trivial, but showing that the\nset is non-empty will ask you to use techniques learned in the first world.\n", "-- definition is_upper_bound' (S : set \u211d) (x : \u211d) := x \u2208 upper_bounds S \n-- (Definition above deprecated? GT)\ndefinition is_lub (S : set \u211d) (x : \u211d) := is_upper_bound S x \u2227 \n\u2200 y : \u211d, is_upper_bound S y \u2192 x \u2264 y\ndefinition has_lub (S : set \u211d) := \u2203 x, is_lub S x \n", "local attribute [instance] classical.prop_decidable --hide\n", "Any set of reals that has a supremum is non-empty and bounded above.\n", "end xena -- hide\n", "cases H with b Hb,\n  -- b is LUB, Hb is proof it's LUB\n  split,\n  { -- first prove S is not empty, by contradiction as usual with empty sets\n    intro Hempty,\n    have H1 : (b-1) \u2208 upper_bounds S,\n    change \u2200 x \u2208 S, x \u2264 (b-1),\n    by_contradiction hn,\n    push_neg at hn,\n    cases hn with x h1, \n    cases h1 with h11 h12,\n    rw Hempty at h11, \n    exact h11, \n    unfold is_lub at Hb,\n    have HH := Hb.2 (b-1) H1, -- b - 1 is an upper bound\n    linarith,\n  },\n  {\n     existsi b,\n     exact Hb.1,\n  }, \n  done\n", "import data.real.basic\nimport tactic.suggest\nimport game.Completeness.level01\nnoncomputable theory\nopen_locale classical\ndef upper_bound (A : set \u211d) (x : \u211d) := \u2200 a \u2208 A, a \u2264 x\ndef is_sup (A : set \u211d) (x : \u211d) := upper_bound A x \u2227 \u2200 y, upper_bound A y \u2192 x \u2264 y\ntheorem helper_lemma (x y : \u211d) (H : x < y) : x < (x + y) / 2 \u2227 (x + y) / 2 < y :=\nbegin\n  have two_ge_zero : (2 : \u211d) \u2265 0 := by norm_num,\n  split,\n  { apply lt_of_mul_lt_mul_right _ two_ge_zero,\n    rw [mul_two,div_mul_cancel],\n    apply add_lt_add_left H,\n    norm_num},\n  { apply lt_of_mul_lt_mul_right _ two_ge_zero,\n    rw [div_mul_cancel,mul_two],\n    apply add_lt_add_right H,\n    norm_num,\n  },\nend\n", "-- these three helper results to go in sidebar\nlemma two_real_ne_zero : (2:\u211d) \u2260 0 :=\nbegin\n    intro, linarith,\nend\nlemma avg_lt_max {mn mx: \u211d} (H : mn < mx) : (mn+mx) / 2 < mx :=\nbegin\n  apply (mul_lt_mul_right (show (0:\u211d)<2, by norm_num)).1,\n  rw [div_mul_cancel _ (two_real_ne_zero)],\n  simp [H,mul_two],\nend\nlemma min_lt_avg {mn mx: \u211d} (H : mn < mx) : mn < (mn+mx) / 2 :=\nbegin\n  apply (mul_lt_mul_right (show (0:\u211d)<2, by norm_num)).1,\n  rw [div_mul_cancel _ (two_real_ne_zero)],\n  simp [H,mul_two],\nend\n", "example (a b : \u211d) (h : a < b): is_sup (set.Ioo a b) b :=\nbegin\n  unfold is_sup,\n  split,\n  intro t,\n  intro j,\n  rw set.Ioo at j,\n  cases j with d hd,\n  exact le_of_lt hd,\n  intro t,\n  intro j,\n  apply le_of_not_gt,\n  intro k,\n  rcases lt_trichotomy a t with han | haz | hap,\n  have L : t + t < b + t, linarith, ring at L,\n  have L1 : (t + b) / 2 < b, linarith,\n  have P : t + b < b + b, linarith, ring at P,\n  have P1 : t < (t + b) / 2, linarith,\n  have s : a < (t + b) / 2, linarith,\n  have avgIn : a < (t + b) / 2 \u2227 (t + b) / 2 < b,\n  split,\n  exact s, exact L1,\n  have R : ((t + b) / 2) \u2208 set.Ioo a b,\n  split,\n  exact s,\n  exact L1,\n  unfold upper_bound at j,\n  revert j,\n  contrapose!,\n  intro q,\n  use ((t + b) / 2),\n  split,\n  exact R,\n  exact P1,\n  have L : a + a < a + b, linarith, ring at L,\n  have L1 : a < (a + b) / 2, linarith,\n  have P : a + b < b + b, linarith, ring at P,\n  have P1 : (a + b) / 2 < b, linarith,\n  have s : a < (a + b) / 2, linarith,\n  have avgIn : a < (a + b) / 2 \u2227 (a + b) / 2 < b,\n  split,\n  exact s, exact P1,\n  have R : ((a + b) / 2) \u2208 set.Ioo a b,\n  split,\n  exact s,\n  exact P1,\n  unfold upper_bound at j,\n  revert j,\n  contrapose!,\n  intro q,\n  use ((a + b) / 2),\n  split,\n  exact R,\n  rw \u2190 haz,\n  exact s,\n  have L : a + a < a + b, linarith, ring at L,\n  have L1 : a < (a + b) / 2, linarith,\n  have P : a + b < b + b, linarith, ring at P,\n  have P1 : (a + b) / 2 < b, linarith,\n  have W : t < (a + b) / 2, linarith,\n  have R : ((a + b) / 2) \u2208 set.Ioo a b,\n  split,\n  exact L1,\n  exact P1,\n  unfold upper_bound at j,\n  revert j,\n  contrapose!,\n  intro q,\n  use ((a + b) / 2),\n  split,\n  exact R,\n  exact W,\nend", "import data.real.basic\nimport game.Completeness.level04\nnoncomputable theory\nopen_locale classical\ndefinition has_lub (S : set \u211d) := \u2203 x, is_lub S x\ndefinition is_upper_bound (S : set \u211d) (x : \u211d) := \u2200 s \u2208 S, s \u2264 x \ndefinition is_lub_plzwork (S : set \u211d) (x : \u211d) := is_upper_bound S x \u2227 \n\u2200 y : \u211d, is_upper_bound S y \u2192 x \u2264 y\n", "lemma unique_LUB (A : set \u211d) (x y : \u211d) (H : has_lub A) (hx : is_lub A x) (hy : is_lub A y) : x = y :=\nbegin\n  cases hx with d hd,\n  cases hy with f hf,\n\n  specialize hd y,\n  specialize hf x,\n  specialize hf d,\n  specialize hd f,\n  linarith,\nend\n", "theorem nonempty_and_bounded_has_unique_LUB (x y : \u211d) (S : set \u211d) (H : has_lub S) (hx : is_lub_plzwork S x) (hy : is_lub_plzwork S y) : \n (S \u2260 \u2205) \u2227 (has_lub S) \u2192 x = y :=\nbegin\n  intro h,\n  cases h with t ht,\n  cases ht with t ht,\n  cases hx with d hd,\n  cases hy with f hf,\n  --specialize hd y,\n  specialize hf x,\n  specialize hd y,\n  specialize hf d,\n  specialize hd f,\n  linarith,\nend\n", "import data.real.basic\nimport game.Completeness.level04\nimport game.Completeness.level02\nnoncomputable theory\nopen_locale classical\nlemma inv_succ_pos : \u2200 n : \u2115, 1/(n+1 : \u211d) > 0 :=\nbegin\n  -- Let `n` be any integer\n  intro n,\n  -- Since we don't know the name of the relevant lemma, asserting that the inverse of\n  -- a positive number is positive, let's state that is suffices\n  -- to prove that `n+1`, seen as a real number, is positive, and ask `library_search`\n  suffices : (n + 1 : \u211d) > 0,\n  { library_search },\n  -- Now we want to reduce to a statement about natural numbers, not real numbers\n  -- coming from natural numbers.\n  norm_cast,\n  -- and then get the usual help from `linarith`\n  linarith,\nend\nexample  (S : set \u211d) (n : \u2115) (H : S = {3 - 1 / n}) : is_sup S 3 :=\nbegin\n  rw is_sup,\n  split,\n  intro h,\n  intro j,\n  rw H at j,\n  cases n with n hn,\n  simp at H,\n  simp at j,\n  rw j,\n  rw nat.succ_eq_add_one at H,\n  rw nat.succ_eq_add_one at j,\n  --simp at j,\n  --rw j,\n  --revert j,\n  --contrapose!,\n  --intro j,\n  --intro f,\n  have L := inv_succ_pos,\n  rw self\n  have P : 3 - 1 / \u2191(n + 1) > 0,\n  sorry,\n  sorry,\n  intro h,\n  intro j,\n  rw upper_bound at j,\n  apply j,\n  rw H at j,\n  rw H,\n  cases n with d hd,\n  norm_num,\n  sorry,\n  --return at later date (preferably never)\nend\n", "rw upper_bound,\n  intro j,\n  intro k,\n  rw H at k,\n  cases k with k hk,\n  cases k with d hd,\n\n\n\n\n  \n", "import data.real.basic\nimport game.Completeness.level04\nimport game.Completeness.level02\nnoncomputable theory\nopen_locale classical\ndefinition has_lub (S : set \u211d) := \u2203 x, is_lub S x\n--sup(S) - \u03b5 < s < sup(S)\nlemma thinklater (S : set \u211d) (x y \u03b5 : \u211d) (H : has_lub S) (S \u2260 \u2205) (hy : is_sup S y) : \n  \u2200 \u03b5 > 0, \u2203 x \u2208 S, is_sup S y - \u03b5 < x \u2227 x \u2264 is_sup S y :=\nbegin\nend\n", "Limit Stuff", "import game.sets.L01defs\nimport game.sup_inf.GLBprop_if_LUBprop\nimport data.real.basic\nimport tactic.linarith\n", "namespace xena -- hide\n", "local notation `|`x`|` := abs x\ndefinition is_limit (a : \u2115 \u2192 \u211d) (\u03b1 : \u211d) := \n  \u2200 \u03b5 : \u211d, 0 < \u03b5 \u2192 \u2203 N : \u2115, \u2200 n : \u2115, N \u2264 n \u2192 |a n - \u03b1| < \u03b5\ndef seq (n : \u2115) (a : \u2115 \u2192 \u211d) := a n\ndef limit (n : \u2115) (a : \u2115 \u2192 \u211d) (L : \u211d) := \u2200 \u03b5 > 0, \u2203 N : \u2115, n \u2265 N \u2192 |a n - L | < \u03b5\ndefinition is_limit' (a : \u2115 \u2192 \u211d) (\u03b1 : \u211d) := \n  \u2200 \u03b5 : \u211d, 0 < \u03b5 \u2192 \u2203 N : \u2115, \u2200 n : \u2115, N \u2264 n \u2192 |a n - \u03b1| \u2264 \u03b5\nlemma lim_le_iff_lim_lt {L : \u211d}{n : \u2115}(a : \u2115 \u2192 \u211d) : ((is_limit a L) \u2194 (is_limit' a L)):=\nbegin\nsplit,\nintros h \u03b5 h\u03b5,\nhave Q := h(\u03b5)(h\u03b5),\ncases Q with N hN,\nuse N,\nintros n hn,\nhave R := hN(n)(hn),\nlinarith,\nintros h \u03b5 h\u03b5,\nhave h\u03b5' : 0 < (\u03b5 / 2), by linarith, \nhave S := h(\u03b5/2)(h\u03b5'),\ncases S with N hN,\nuse N,\nintros n hn,\nhave T := hN(n)(hn),\nlinarith,\nend\nlemma lim_add (a : \u2115 \u2192 \u211d) (b : \u2115 \u2192 \u211d) (\u03b1 \u03b2 : \u211d) \n    (ha : is_limit a \u03b1) (hb : is_limit b \u03b2) : \n    is_limit ( \u03bb n, (a n) + (b n) ) (\u03b1 + \u03b2) :=\nbegin\n  intro \u03b5,\n  intro j,\n  set e := \u03b5 / 2 with hedef,\n  have he : 0 < e,\n  linarith,\n  have Ha := ha e he,\n  have Hb := hb e he,\n  cases Ha with d hd,\n  cases Hb with t ht,\n  set m := max d t with hm,\n  have q : m \u2265 d, norm_num, left, linarith,\n  have  r : m \u2265 t, norm_num, right, linarith,\n  use m,\n  intros v hv,\n  have I : v \u2265 d, linarith,\n  have O : v \u2265 t, linarith,\n  have W := hd v I,\n  have X := ht v O,\n  have H := abs_add (a v - \u03b1) (b v - \u03b2),\n  simp,\n  have G : a v - \u03b1 + (b v - \u03b2) = a v + b v - (\u03b1 + \u03b2), linarith,\n  rw G at H,\n  have F : |a v - \u03b1| + |b v - \u03b2| < 2 * e, linarith,\n  have E : |a v + b v - (\u03b1 + \u03b2)| < 2 * e, linarith,\n  have D : 2 * e = \u03b5, linarith,\n  rw D at E,\n  exact E,\nend\n", "end xena -- hide"]]}